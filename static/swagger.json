{
	"consumes": [
		"application/json"
	],
	"definitions": {
		"Accounts.Company": {
			"properties": {
				"display_name": {
					"description": "The display name of the company.",
					"type": "string"
				},
				"id": {
					"description": "The ID  of the company.",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Accounts.GetAccountInformationResponse": {
			"properties": {
				"company": {
					"allOf": [
						{
							"$ref": "#/definitions/Accounts.Company"
						}
					],
					"description": "The company details that was requested."
				},
				"display_name": {
					"description": "The user's display name.",
					"type": "string"
				},
				"id": {
					"description": "The user's ID.",
					"type": "string"
				}
			},
			"title": "GetAccountInformationResponse is the response for the GetAccountInformation rpc",
			"type": "object"
		},
		"Accounts.GetCompanyDisplayNameResponse": {
			"description": "GetDisplayNameResponse is the response for the GetCompanyDisplayName rpc.",
			"properties": {
				"company_display_name": {
					"description": "The display name of the company ID that was requested.",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Accounts.ListDisplayNamesResponse": {
			"description": "GetDisplayNameResponse is the response for the GetDisplayName rpc.",
			"properties": {
				"pagination": {
					"allOf": [
						{
							"$ref": "#/definitions/PaginationResponse"
						}
					],
					"description": "The pagination response."
				},
				"users": {
					"description": "The list of display names and company names for the returned users.",
					"items": {
						"$ref": "#/definitions/Accounts.UserAndCompanyDisplayName",
						"type": "object"
					},
					"type": "array"
				}
			},
			"type": "object"
		},
		"Accounts.UserAndCompanyDisplayName": {
			"properties": {
				"company_id": {
					"description": "The company id that the requested user ID belongs to.",
					"type": "string"
				},
				"company_name": {
					"description": "The company that the requested user ID belongs to.",
					"type": "string"
				},
				"user_display_name": {
					"description": "The display name for the requested user ID.",
					"type": "string"
				},
				"user_id": {
					"description": "The id for the requested user ID",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Activation_Destinations.ActivationDestinationOverview": {
			"description": "ActivationDestinationInstanceOverview provides an overview of a Destination instance for pushing activation queries.",
			"properties": {
				"created_time": {
					"description": "CreatedTime is the date and time the destination was created.",
					"format": "date-time",
					"type": "string"
				},
				"description": {
					"description": "Description is an optional description given to this destination.",
					"type": "string"
				},
				"destination_type_id": {
					"description": "DestinationTypeId is the InfoSum type ID of this destination.",
					"type": "string"
				},
				"id": {
					"description": "ID is the globally unique ID of the destination.",
					"type": "string"
				},
				"name": {
					"description": "Name is the display name given to this destination.",
					"type": "string"
				},
				"owner_id": {
					"description": "OwnerId is the company ID of the owner of the destination.",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Activation_Destinations.GetActivationDestinationPushSchemaResponse": {
			"description": "GetActivationDestinationPushSchemaResponse is the output of the GetActivationDestinationPushSchema method.",
			"properties": {
				"push_schema": {
					"description": "The push time schema for the requested destination instance. The `push_config` on push requests to this destination must satisfy this schema.",
					"type": "object"
				}
			},
			"type": "object"
		},
		"Activation_Destinations.ListActivationDestinationsResponse": {
			"description": "ListActivationDestinationsResponse is the output of the ListActivationDestinations method.",
			"properties": {
				"destinations": {
					"description": "Activation Destination overviews.",
					"items": {
						"$ref": "#/definitions/Activation_Destinations.ActivationDestinationOverview",
						"type": "object"
					},
					"type": "array"
				},
				"pagination": {
					"$ref": "#/definitions/PaginationResponse"
				}
			},
			"type": "object"
		},
		"Activation_Destinations.NullValue": {
			"default": "NULL_VALUE",
			"description": "`NullValue` is a singleton enumeration to represent the null value for the\n`Value` type union.\n\nThe JSON representation for `NullValue` is JSON `null`.\n\n - NULL_VALUE: Null value.",
			"enum": [
				"NULL_VALUE"
			],
			"type": "string"
		},
		"Activation_Destinations.PushActivationResultsBody": {
			"description": "PushActivationResultsRequest is input to the ExportResult request.",
			"properties": {
				"push_config": {
					"description": "Configuration following the push time schema for the destination instance. Default values from the underlying instance can be found in the push schema `default` annotations. Defaults will not be used unless they are re-submitted as part of this config. Submit the `X-INFOSUM-REDACTED` keyword for `x-infosum-secret` properties to retain their default value from the underlying destination instance.",
					"type": "object"
				}
			},
			"type": "object"
		},
		"Activation_Destinations.PushActivationResultsResponse": {
			"description": "PushActivationResultsResponse is the output of the PushActivationResults request.",
			"properties": {
				"push_id": {
					"description": "ID for the requested push.",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Activation_Pushes.ActivationPushDetails": {
			"description": "ActivationPushDetails is the details of a specific activation push.",
			"properties": {
				"completed_at_date_time": {
					"description": "The date and time when this activation push was completed, either successfully or not.",
					"format": "date-time",
					"type": "string"
				},
				"destination_id": {
					"description": "The Destination ID used for the activation push.",
					"type": "string"
				},
				"destination_type_id": {
					"description": "The ID of the Destination type used for the activation push.",
					"type": "string"
				},
				"push_config": {
					"description": "The redacted push time config. It is the full redacted config if the user owns the destination.",
					"type": "object"
				},
				"push_error": {
					"allOf": [
						{
							"$ref": "#/definitions/Error"
						}
					],
					"description": "The activation push error in case of failures."
				},
				"push_id": {
					"description": "The ID of the activation push.",
					"type": "string"
				},
				"push_successful": {
					"description": "Indicates whether this activation query completed successfully or not.",
					"type": "boolean"
				},
				"query_id": {
					"description": "The ID of the query that has been pushed.",
					"type": "string"
				},
				"started_at_date_time": {
					"description": "The date and time when this activation push was started.",
					"format": "date-time",
					"type": "string"
				},
				"status": {
					"description": "The status of the activation push",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Activation_Pushes.ActivationPushOverview": {
			"description": "ActivationPushOverview is the overview of a specific activation push.",
			"properties": {
				"completed_at_date_time": {
					"description": "The date and time when this activation push was completed, either successfully or not.",
					"format": "date-time",
					"type": "string"
				},
				"destination_id": {
					"description": "The Destination ID used for the activation push.",
					"type": "string"
				},
				"destination_type_id": {
					"description": "The ID of the Destination type used for the activation push.",
					"type": "string"
				},
				"push_error": {
					"allOf": [
						{
							"$ref": "#/definitions/Error"
						}
					],
					"description": "The activation push error in case of failures."
				},
				"push_id": {
					"description": "The ID of the activation push.",
					"type": "string"
				},
				"push_successful": {
					"description": "Indicates whether this activation query completed successfully or not.",
					"type": "boolean"
				},
				"query_id": {
					"description": "The ID of the query that has been pushed.",
					"type": "string"
				},
				"started_at_date_time": {
					"description": "The date and time when this activation push was started.",
					"format": "date-time",
					"type": "string"
				},
				"status": {
					"description": "The status of the activation push",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Activation_Pushes.GetActivationPushResponse": {
			"description": "GetActivationPushResponse is the output of the GetActivationPush method.",
			"properties": {
				"push_details": {
					"allOf": [
						{
							"$ref": "#/definitions/Activation_Pushes.ActivationPushDetails"
						}
					],
					"description": "Details of the requested activation push."
				}
			},
			"type": "object"
		},
		"Activation_Pushes.ListActivationPushesResponse": {
			"description": "ListActivationPushesResponse is the response of the ListActivationPushes method.",
			"properties": {
				"activation_pushes": {
					"description": "A list of activation push overviews.",
					"items": {
						"$ref": "#/definitions/Activation_Pushes.ActivationPushOverview",
						"type": "object"
					},
					"type": "array"
				},
				"pagination_response": {
					"allOf": [
						{
							"$ref": "#/definitions/PaginationResponse"
						}
					],
					"description": "The pagination response which can tell whether more results are available or not."
				}
			},
			"type": "object"
		},
		"Activation_Pushes.NullValue": {
			"default": "NULL_VALUE",
			"description": "`NullValue` is a singleton enumeration to represent the null value for the\n`Value` type union.\n\nThe JSON representation for `NullValue` is JSON `null`.\n\n - NULL_VALUE: Null value.",
			"enum": [
				"NULL_VALUE"
			],
			"type": "string"
		},
		"Automation_Configs.AutomationStep": {
			"description": "The information required to define an Automation Step. Provide only one config per Automation Step.",
			"properties": {
				"import": {
					"allOf": [
						{
							"$ref": "#/definitions/Automation_Configs.ImportConfig"
						}
					],
					"description": "The Import Config to execute for this Automation Step."
				},
				"normalization": {
					"allOf": [
						{
							"$ref": "#/definitions/Automation_Configs.NormalizationConfig"
						}
					],
					"description": "The Normalization Config to execute for this Automation Step."
				},
				"publish": {
					"allOf": [
						{
							"$ref": "#/definitions/Automation_Configs.PublishConfig"
						}
					],
					"description": "The Publish Config to execute for this Automation Step."
				},
				"recordset_creation": {
					"allOf": [
						{
							"$ref": "#/definitions/Automation_Configs.RecordsetCreationConfig"
						}
					],
					"description": "The Recordset Creation Config to execute for this Automation Step."
				}
			},
			"type": "object"
		},
		"Automation_Configs.Config": {
			"description": "The information required to define an Automation Config.",
			"properties": {
				"automation_steps": {
					"description": "The sequence of tasks which constitute an Execution of this Automation Config.",
					"items": {
						"$ref": "#/definitions/Automation_Configs.AutomationStep",
						"type": "object"
					},
					"type": "array"
				},
				"cloud_vault_id": {
					"description": "The ID of the Cloud Vault to be used for reading and writing data during Automation Execution.",
					"type": "string"
				},
				"created_by": {
					"description": "The ID of the user who created the Automation Config. All tasks executed under this Automation Config will be executed with this user ID.",
					"type": "string"
				},
				"created_date_time": {
					"description": "The UTC date-time the Automation Config was created in RFC3339 format. Output Only.",
					"format": "date-time",
					"type": "string"
				},
				"cron_timer": {
					"description": "The execution schedule of the Automation in UNIX CRON format as described in https://man7.org/linux/man-pages/man5/crontab.5.html. The schedule is executed relative to the supplied `timezone_identifier` for the Automation.",
					"example": "0 12 * * *",
					"type": "string"
				},
				"description": {
					"description": "The user-friendly description of the Automation Config.",
					"type": "string"
				},
				"enabled": {
					"description": "The 'enabled' flag allows Automation Execution triggers to be paused and resumed without adjusting the rest of the config or schedule.",
					"type": "boolean"
				},
				"end_date_time": {
					"description": "Optional date-time to cease triggering Automation Executions. Format is RFC3339 which defaults to UTC. This parameter is unaffected by `timezone_identifier`. An empty value indicates that the schedule should never cease.",
					"example": "2019-11-22T22:30:00Z",
					"format": "date-time",
					"type": "string"
				},
				"id": {
					"description": "The immutable, globally unique ID of the Automation Config. Output Only.",
					"type": "string"
				},
				"name": {
					"description": "The user-friendly name of the Automation Config.",
					"type": "string"
				},
				"start_date_time": {
					"description": "Optional date-time to begin triggering Automation Executions based on the CRON schedule. Format is RFC3339 which defaults to UTC. This parameter is unaffected by `timezone_identifier`. An empty value indicates that the schedule should begin as soon as possible.",
					"example": "2019-11-22T22:30:00Z",
					"format": "date-time",
					"type": "string"
				},
				"timezone_identifier": {
					"description": "The Timezone Identifier to schedule Automation Executions relative to using the `cron_timer`. This parameter does not affect the start or end times for scheduling. The format is from the IANA TZ database: https://en.wikipedia.org/wiki/List_of_tz_database_time_zones. Be aware that scheduling near the lost or gained hour in a timezone which implements daylight savings time (DST) can lead to schedule disruption during transitions.",
					"example": "Europe/London",
					"type": "string"
				},
				"updated_date_time": {
					"description": "The UTC date-time the Automation Config was last updated in RFC3339 format. Output Only.",
					"format": "date-time",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Automation_Configs.CreateConfigRequest": {
			"description": "CreateConfigRequest is the information provided when creating an Automation Config.",
			"properties": {
				"cloud_vault_id": {
					"description": "The ID of the Cloud Vault to be used for reading and writing data during Automation Execution.",
					"type": "string"
				},
				"cron_timer": {
					"description": "The execution schedule of the Automation in UNIX CRON format as described in https://man7.org/linux/man-pages/man5/crontab.5.html. The schedule is executed relative to the supplied `timezone_identifier` for the Automation.",
					"example": "0 12 * * *",
					"type": "string"
				},
				"description": {
					"description": "The user-friendly description of the Automation Config.",
					"type": "string"
				},
				"enabled": {
					"description": "The 'enabled' flag allows Automation Execution triggers to be paused and resumed without adjusting the rest of the config or schedule.",
					"type": "boolean"
				},
				"end_date_time": {
					"description": "Optional date-time to cease triggering Automation Executions. Format is RFC3339 which defaults to UTC. Offsets relative to Zulu time must be provided to convey local times. This parameter is unaffected by `timezone_identifier`. An empty value indicates that the schedule should never cease.",
					"example": "2019-11-23T18:30:00-04:00",
					"format": "date-time",
					"type": "string"
				},
				"name": {
					"description": "The user-friendly name of the Automation Config. Valid characters are alphanumeric, '_', '-' and spaces.",
					"type": "string"
				},
				"start_date_time": {
					"description": "Optional date-time to begin triggering Automation Executions based on the CRON schedule. Format is RFC3339 which defaults to UTC. Offsets relative to Zulu time must be provided to convey local times. This parameter is unaffected by `timezone_identifier`. An empty value indicates that the schedule should begin as soon as possible.",
					"example": "2019-11-22T18:30:00-04:00",
					"format": "date-time",
					"type": "string"
				},
				"steps": {
					"description": "The sequence of tasks which constitute an Execution of this Automation Config.",
					"items": {
						"$ref": "#/definitions/Automation_Configs.AutomationStep",
						"type": "object"
					},
					"type": "array"
				},
				"timezone_identifier": {
					"description": "The Timezone Identifier to schedule Automation Executions relative to using the `cron_timer`. This parameter does not affect the start or end times for scheduling. The format is from the IANA TZ database: https://en.wikipedia.org/wiki/List_of_tz_database_time_zones. Be aware that scheduling near the lost or gained hour in a timezone which implements daylight savings time (DST) can lead to schedule disruption during transitions.",
					"example": "Europe/London",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Automation_Configs.CreateConfigResponse": {
			"description": "CreateConfigResponse is the response from creating an Automation Config.",
			"properties": {
				"config": {
					"allOf": [
						{
							"$ref": "#/definitions/Automation_Configs.Config"
						}
					],
					"description": "The new Automation Config.",
					"title": "The returned automation config"
				}
			},
			"type": "object"
		},
		"Automation_Configs.DeleteConfigResponse": {
			"description": "Success returns an empty response body.",
			"type": "object"
		},
		"Automation_Configs.GetConfigResponse": {
			"description": "GetConfigResponse returns the requested Automation Config.",
			"properties": {
				"config": {
					"allOf": [
						{
							"$ref": "#/definitions/Automation_Configs.Config"
						}
					],
					"description": "Details of the requested Automation Config."
				},
				"last_execution_id": {
					"description": "The ID of the last Execution triggered by the Automation Config, if one exists.",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Automation_Configs.ImportConfig": {
			"description": "A config used to define an Import as an Automation Step.",
			"properties": {
				"config_id": {
					"description": "The Importer ID to execute for the Automation Step.",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Automation_Configs.ListConfigsResponse": {
			"description": "ListConfigsResponse returns the Automation Configs which matched the request parameters.",
			"properties": {
				"configs": {
					"description": "Array of Automation Configs based on the request filters and sorting.",
					"items": {
						"$ref": "#/definitions/Automation_Configs.Config",
						"type": "object"
					},
					"type": "array"
				},
				"pagination": {
					"allOf": [
						{
							"$ref": "#/definitions/PaginationResponse"
						}
					],
					"description": "Pagination information for returned Configs."
				}
			},
			"type": "object"
		},
		"Automation_Configs.NormalizationConfig": {
			"description": "A config to define Normalization as an Automation Step.",
			"properties": {
				"config_id": {
					"description": "The Normalization Config ID to execute for the Automation Step.",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Automation_Configs.PublishConfig": {
			"description": "A config to define Preparation and Publishing as an Automation Step.",
			"properties": {
				"config_id": {
					"description": "The Dataset Prepare Config ID to execute for the Automation Step.",
					"type": "string"
				},
				"dataset_id": {
					"description": "The ID of the dataset to publish the prepared data to.",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Automation_Configs.RecordsetCreationConfig": {
			"description": "A config to define Recordset Creation as an Automation Step.",
			"properties": {
				"config_id": {
					"description": "The Recordset Creation Config ID to execute for the Automation Step.",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Automation_Configs.UpdateConfigResponse": {
			"description": "UpdateConfigResponse is the response from updating an Automation.",
			"properties": {
				"config": {
					"allOf": [
						{
							"$ref": "#/definitions/Automation_Configs.Config"
						}
					],
					"description": "The updated Automation Config."
				}
			},
			"type": "object"
		},
		"Automation_Configs.v2.UpdateConfig": {
			"description": "The mutable fields of an Automation.",
			"properties": {
				"cron_timer": {
					"description": "The execution schedule of the Automation in UNIX CRON format as described in https://man7.org/linux/man-pages/man5/crontab.5.html. The schedule is executed relative to the supplied `timezone_identifier` for the Automation.",
					"example": "0 12 * * *",
					"type": "string"
				},
				"description": {
					"description": "The user-friendly description of the Automation Config.",
					"type": "string"
				},
				"enabled": {
					"description": "The 'enabled' flag allows Automation Execution triggers to be paused and resumed without adjusting the rest of the config or schedule.",
					"type": "boolean"
				},
				"end_date_time": {
					"description": "Optional date-time to cease triggering Automation Executions. Format is RFC3339 which defaults to UTC. Offsets relative to Zulu time must be provided to convey local times. This parameter is unaffected by `timezone_identifier`. An empty value indicates that the schedule should never cease.",
					"example": "2019-11-22T18:30:00-04:00",
					"format": "date-time",
					"type": "string"
				},
				"name": {
					"description": "The user-friendly name of the Automation Config. Valid characters are alphanumeric, '_', '-' and spaces.",
					"type": "string"
				},
				"start_date_time": {
					"description": "Optional date-time to begin triggering Automation Executions based on the CRON schedule. Format is RFC3339 which defaults to UTC. Offsets relative to Zulu time must be provided to convey local times. This parameter is unaffected by `timezone_identifier`. An empty value indicates that the schedule should begin as soon as possible.",
					"example": "2019-11-22T18:30:00-04:00",
					"format": "date-time",
					"type": "string"
				},
				"timezone_identifier": {
					"description": "The Timezone Identifier to schedule Automation Executions relative to using the `cron_timer`. This parameter does not affect the start or end times for scheduling. The format is from the IANA TZ database: https://en.wikipedia.org/wiki/List_of_tz_database_time_zones. Be aware that scheduling near the lost or gained hour in a timezone which implements daylight savings time (DST) can lead to schedule disruption during transitions.",
					"example": "Europe/London",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Automation_Execution.ExecuteResponse": {
			"description": "ExecuteResponse returns the requested Automation Execution ID.",
			"properties": {
				"execution_id": {
					"description": "The ID of the Execution created by the Execute request.",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Automation_Execution.Execution": {
			"description": "The information required to manage an automation execution.",
			"properties": {
				"cloud_vault_id": {
					"description": "The ID of the Cloud Vault used by the Execution.",
					"type": "string"
				},
				"config_id": {
					"description": "The Automation Config ID that the Execution ran.",
					"type": "string"
				},
				"current_automation_step": {
					"allOf": [
						{
							"$ref": "#/definitions/Automation_Execution.TaskType"
						}
					],
					"description": "The current Step of the Execution."
				},
				"current_step_status": {
					"allOf": [
						{
							"$ref": "#/definitions/Automation_Execution.v1.Status"
						}
					],
					"description": "The status of the current Execution Step."
				},
				"error": {
					"allOf": [
						{
							"$ref": "#/definitions/Error"
						}
					],
					"description": "The error encountered by the Execution if it failed."
				},
				"executed_by": {
					"description": "The ID of the user that triggered the Execution if it was manually triggered.",
					"type": "string"
				},
				"id": {
					"description": "The immutable, globally unique ID of the Automation Execution.",
					"type": "string"
				},
				"last_updated_date_time": {
					"description": "The UTC date-time the Execution was last updated.",
					"format": "date-time",
					"type": "string"
				},
				"started_date_time": {
					"description": "The UTC date-time the Execution was started.",
					"format": "date-time",
					"type": "string"
				}
			},
			"readOnly": true,
			"type": "object"
		},
		"Automation_Execution.ExecutionStep": {
			"description": "ExecutionStep used to track the automation execution.",
			"properties": {
				"automation_execution_id": {
					"description": "The ID of the Automation Execution that this Step belongs to.",
					"type": "string"
				},
				"current_task_status": {
					"allOf": [
						{
							"$ref": "#/definitions/Automation_Execution.v1.Status"
						}
					],
					"description": "The status of this Step."
				},
				"error": {
					"allOf": [
						{
							"$ref": "#/definitions/Error"
						}
					],
					"description": "The error encountered by this Step if it failed"
				},
				"started_date_time": {
					"description": "The UTC date-time that the Step began executing.",
					"format": "date-time",
					"type": "string"
				},
				"task_config_id": {
					"description": "The ID of the task config executed in this Step. The type of this config corresponds to the 'task_type' parameter.",
					"type": "string"
				},
				"task_id": {
					"description": "The ID of the task executed for this Step. The type of task that this ID corresponds to is described by the 'task_type' parameter.",
					"type": "string"
				},
				"task_type": {
					"allOf": [
						{
							"$ref": "#/definitions/Automation_Execution.TaskType"
						}
					],
					"description": "The type of task that was executed for this Step."
				},
				"updated_date_time": {
					"description": "The UTC date-time that the Step was last updated.",
					"format": "date-time",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Automation_Execution.GetExecutionResponse": {
			"description": "GetExecutionResponse returns the requested Automation Execution.",
			"properties": {
				"execution": {
					"allOf": [
						{
							"$ref": "#/definitions/Automation_Execution.Execution"
						}
					],
					"description": "Details of the requested Automation Execution."
				},
				"execution_steps": {
					"description": "The Automation Steps already executed at the time of the request.",
					"items": {
						"$ref": "#/definitions/Automation_Execution.ExecutionStep",
						"type": "object"
					},
					"type": "array"
				}
			},
			"type": "object"
		},
		"Automation_Execution.ListExecutionResponse": {
			"description": "ListExecutionResponse returns the matching resources.",
			"properties": {
				"executions": {
					"description": "The Automation Executions which matched the criteria of the request.",
					"items": {
						"$ref": "#/definitions/Automation_Execution.Execution",
						"type": "object"
					},
					"type": "array"
				},
				"pagination": {
					"allOf": [
						{
							"$ref": "#/definitions/PaginationResponse"
						}
					],
					"description": "Details of the pagination of this response."
				}
			},
			"type": "object"
		},
		"Automation_Execution.TaskType": {
			"default": "TASK_TYPE_INVALID",
			"description": "TaskType is an enum of all the potential task types.",
			"enum": [
				"TASK_TYPE_INVALID",
				"TASK_TYPE_IMPORT",
				"TASK_TYPE_RECORDSET",
				"TASK_TYPE_NORMALIZATION",
				"TASK_TYPE_PREPARE",
				"TASK_TYPE_PUBLISH"
			],
			"type": "string"
		},
		"Automation_Execution.v1.Status": {
			"default": "NO_STATUS",
			"description": "Status is an enum of the different states that an async task can be in.",
			"enum": [
				"NO_STATUS",
				"WAITING",
				"INITIALIZING",
				"RUNNING",
				"FAILED",
				"COMPLETED",
				"CANCELING",
				"CANCELED",
				"STALE",
				"PROVISIONING",
				"PROVISIONED",
				"PARTIALLY_COMPLETED"
			],
			"type": "string"
		},
		"BucketOrigin": {
			"default": "BUCKET_ORIGIN_INVALID",
			"description": "BucketOrigin denoted whether the bucket is supplied by InfoSum or the customer.",
			"enum": [
				"BUCKET_ORIGIN_INVALID",
				"INFOSUM",
				"BYOB"
			],
			"type": "string"
		},
		"CloudVaultMetadata": {
			"description": "CloudVaultMetadata is the data about a Cloud Vault.",
			"properties": {
				"aws_kms_key_arn": {
					"type": "string"
				},
				"bucket_name": {
					"type": "string"
				},
				"bucket_origin": {
					"$ref": "#/definitions/BucketOrigin"
				},
				"endpoint_url": {
					"type": "string"
				},
				"prefix": {
					"type": "string"
				},
				"region": {
					"$ref": "#/definitions/Region"
				}
			},
			"type": "object"
		},
		"CloudVaultsList": {
			"description": "CloudVaultsList contains a list of Cloud Vault IDs.",
			"properties": {
				"cloud_vault_ids": {
					"items": {
						"type": "string"
					},
					"type": "array"
				}
			},
			"type": "object"
		},
		"Cloud_Vaults.CloudVault": {
			"description": "CloudVault is the details about a specific Cloud Vault.",
			"properties": {
				"created_by": {
					"description": "Output only. CreatedBy is the id of the user that created this Cloud Vault.",
					"readOnly": true,
					"type": "string"
				},
				"created_date_time": {
					"description": "Output only. CreatedDateTime is the date and time that this Cloud Vault was\ncreated.",
					"format": "date-time",
					"readOnly": true,
					"type": "string"
				},
				"description": {
					"description": "Description is an optional description given to this Cloud Vault.",
					"type": "string"
				},
				"id": {
					"description": "Output only. ID is the unique identifier of the Cloud Vault.",
					"readOnly": true,
					"type": "string"
				},
				"name": {
					"description": "Name is the display name given to this Cloud Vault.",
					"type": "string"
				},
				"owner_id": {
					"description": "Output only. OwnerId is the id of the owner of this Cloud Vault.",
					"readOnly": true,
					"type": "string"
				},
				"region": {
					"allOf": [
						{
							"$ref": "#/definitions/Cloud_Vaults.Region"
						}
					],
					"description": "Output only. Region identifies the region that this Cloud Vault is located\nin.",
					"readOnly": true
				},
				"updated_date_time": {
					"format": "date-time",
					"readOnly": true,
					"title": "Output only. UpdatedDateTime is the date and time that the Cloud Vault was\nupdated",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Cloud_Vaults.CreateRequest": {
			"properties": {
				"description": {
					"description": "Description is an optional description given to this Cloud Vault.",
					"type": "string"
				},
				"name": {
					"description": "Name is the display name given to this Cloud Vault.",
					"type": "string"
				},
				"region": {
					"allOf": [
						{
							"$ref": "#/definitions/Cloud_Vaults.Region"
						}
					],
					"description": "Region identifies the region that this Cloud Vault is located in.\nExpected format: cloudprovider + region e.g. aws-eu-west-2\nNote: ibm-eu-central-1 is a deprecated value."
				}
			},
			"required": [
				"name",
				"region"
			],
			"type": "object"
		},
		"Cloud_Vaults.CreateResponse": {
			"properties": {
				"cloud_vault": {
					"$ref": "#/definitions/Cloud_Vaults.CloudVault"
				}
			},
			"type": "object"
		},
		"Cloud_Vaults.DeleteResponse": {
			"type": "object"
		},
		"Cloud_Vaults.GetResponse": {
			"properties": {
				"cloud_vault": {
					"$ref": "#/definitions/Cloud_Vaults.CloudVault"
				}
			},
			"type": "object"
		},
		"Cloud_Vaults.ListResponse": {
			"properties": {
				"cloud_vaults": {
					"items": {
						"$ref": "#/definitions/Cloud_Vaults.CloudVault",
						"type": "object"
					},
					"type": "array"
				},
				"pagination": {
					"allOf": [
						{
							"$ref": "#/definitions/PaginationResponse"
						}
					],
					"description": "Pagination is the information on how the results were paginated."
				}
			},
			"type": "object"
		},
		"Cloud_Vaults.Region": {
			"default": "UNKNOWN",
			"description": "Region enumerates the supported cloud providers and locations.\n\n - UNKNOWN: UNKNOWN means the region has not been defined.\n - AWS_EU_WEST_2: AWS_EU_WEST_2 means AWS Europe (London).\n - AWS_US_EAST_1: AWS_US_EAST_1 means AWS US East (N. Virginia).\n - IBM_EU_CENTRAL_1: IBM_EU_CENTRAL_1 means IBM MZR EU Central (Frankfurt).\n - AWS_EU_CENTRAL_1: AWS_EU_CENTRAL_1 means AWS Europe (Frankfurt).\n - AWS_AP_SOUTHEAST_2: AWS_AP_SOUTHEAST_2 means AWS Asia Pacific (Sydney)",
			"enum": [
				"UNKNOWN",
				"AWS_EU_WEST_2",
				"AWS_US_EAST_1",
				"IBM_EU_CENTRAL_1",
				"AWS_EU_CENTRAL_1",
				"AWS_AP_SOUTHEAST_2"
			],
			"type": "string"
		},
		"Cloud_Vaults.UpdateCloudVault": {
			"description": "UpdateCloudVault is used to update a Cloud Vault. Users can only update the\nname, description and auth fields.",
			"properties": {
				"description": {
					"description": "Description is an optional description given to this Cloud Vault.",
					"type": "string"
				},
				"id": {
					"description": "Output only. ID is the unique identifier of the Cloud Vault.",
					"readOnly": true,
					"type": "string"
				},
				"name": {
					"description": "Name is the display name given to this Cloud Vault.",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Cloud_Vaults.UpdateResponse": {
			"properties": {
				"cloud_vault": {
					"$ref": "#/definitions/Cloud_Vaults.CloudVault"
				}
			},
			"type": "object"
		},
		"Connections.CalculateMatchRateRequest": {
			"description": "CalculateMatchRateRequest is the input to the CalculateMatchRate method.",
			"properties": {
				"advertiser_dataset_id": {
					"description": "AdvertiserDatasetId is the ID of the dataset belonging to the advertiser.",
					"type": "string"
				},
				"publisher_dataset_id": {
					"description": "PublisherDatasetId is the ID of the dataset belonging to the publisher.",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Connections.CalculateMatchRateResponse": {
			"description": "CalculateMatchRateResponse is the output of the CalculateMatchRate method.",
			"properties": {
				"match_rate_percentage": {
					"description": "MatchRatePercentage is the intersection as a percentage of the Advertiser dataset. The range of this field is [0-100].",
					"format": "int64",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Dataset_Lineage.GetPublishResponse": {
			"description": "GetPublishResponse is the information returned when getting a published dataset lineage.",
			"properties": {
				"cloud_vault_id": {
					"description": "The ID of the Cloud Vault used to the publish the dataset.",
					"type": "string"
				},
				"lineage": {
					"description": "The lineage of the published dataset.",
					"items": {
						"$ref": "#/definitions/Dataset_Lineage.Lineage",
						"type": "object"
					},
					"type": "array"
				}
			},
			"type": "object"
		},
		"Dataset_Lineage.ImportConfig": {
			"description": "The import config.",
			"properties": {
				"config_id": {
					"description": "The config ID used for the import, if one was used.",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Dataset_Lineage.Lineage": {
			"description": "The lineage config.",
			"properties": {
				"import": {
					"allOf": [
						{
							"$ref": "#/definitions/Dataset_Lineage.ImportConfig"
						}
					],
					"description": "The import config."
				},
				"normalization": {
					"allOf": [
						{
							"$ref": "#/definitions/Dataset_Lineage.NormalizationConfig"
						}
					],
					"description": "The normalization config."
				},
				"publish": {
					"allOf": [
						{
							"$ref": "#/definitions/Dataset_Lineage.PublishConfig"
						}
					],
					"description": "The publish config."
				},
				"recordset_creation": {
					"allOf": [
						{
							"$ref": "#/definitions/Dataset_Lineage.RecordsetCreationConfig"
						}
					],
					"description": "The recordset creation config."
				}
			},
			"type": "object"
		},
		"Dataset_Lineage.NormalizationConfig": {
			"description": "The normalization config.",
			"properties": {
				"config_id": {
					"description": "The config ID used for the normalization, if one was used.",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Dataset_Lineage.PublishConfig": {
			"description": "The publish config.",
			"properties": {
				"config_id": {
					"description": "The config ID used for the publish, if one was used.",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Dataset_Lineage.RecordsetCreationConfig": {
			"description": "The recordset creation config.",
			"properties": {
				"config_id": {
					"description": "The config ID used for the recordset creation, if one was used.",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Dataset_Stats.AttributeColumnStatsResponse": {
			"description": "AttributeColumnStatsResponse is the response returned by AttributeColumnStats method.",
			"properties": {
				"id_to_representations_stats": {
					"additionalProperties": {
						"$ref": "#/definitions/Dataset_Stats.RepresentationStatsList"
					},
					"description": "IdToRepresentationsStats is a map of attribute column ID to a list of their corresponding representations stats.",
					"type": "object"
				}
			},
			"type": "object"
		},
		"Dataset_Stats.ExportColumnStatsResponse": {
			"description": "ExportColumnStatsResponse is the response to ExportColumnStats method.",
			"properties": {
				"valid_values": {
					"description": "ValidValues is the number of valid values for this export column.",
					"format": "uint64",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Dataset_Stats.KeyColumnStatsResponse": {
			"description": "KeyColumnStatsResponse is the response returned by KeyColumnStats method.",
			"properties": {
				"key_id_to_stats": {
					"additionalProperties": {
						"$ref": "#/definitions/Dataset_Stats.v2.KeyColumnStats"
					},
					"description": "KeyIdToStats is a map of key column ID to its corresponding stats.",
					"type": "object"
				}
			},
			"type": "object"
		},
		"Dataset_Stats.RepresentationStats": {
			"description": "RepresentationStats holds stats information for a attribute column representation.",
			"properties": {
				"distinct_values": {
					"description": "DistinctValues is the number of distinct values for this representation.",
					"format": "uint64",
					"type": "string"
				},
				"multi_value": {
					"description": "MultiValue is set to true if this is a multi-value key column.",
					"type": "boolean"
				},
				"representation_id": {
					"description": "RepresentationId is the ID of the representation.",
					"type": "string"
				},
				"valid_values": {
					"description": "ValidValues is the number of valid values for this representation.",
					"format": "uint64",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Dataset_Stats.RepresentationStatsList": {
			"description": "RepresentationStatsList contains a list of RepresentationStats that can be used in a map field.",
			"properties": {
				"representations_stats": {
					"items": {
						"$ref": "#/definitions/Dataset_Stats.RepresentationStats",
						"type": "object"
					},
					"type": "array"
				}
			},
			"type": "object"
		},
		"Dataset_Stats.SummaryStatsResponse": {
			"description": "SummaryStatsResponse is the response returned by SummaryStats method.",
			"properties": {
				"attribute_columns": {
					"description": "AttributeColumns is the number of attributes of the dataset.",
					"format": "uint64",
					"type": "string"
				},
				"export_columns": {
					"description": "ExportColumns is the number of export columns of the dataset.",
					"format": "uint64",
					"type": "string"
				},
				"key_columns": {
					"description": "KeyColumns is the number of keys of the dataset.",
					"format": "uint64",
					"type": "string"
				},
				"total_rows": {
					"description": "TotalRows is the total rows of the dataset.",
					"format": "uint64",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Dataset_Stats.v2.KeyColumnStats": {
			"description": "KeyColumnStats holds stats information for a key column.",
			"properties": {
				"distinct_identifiers": {
					"description": "DistinctIdentifiers is the number of distinct identifiers for this key column.",
					"format": "uint64",
					"type": "string"
				},
				"distinct_values": {
					"description": "DistinctValues is the number of distinct values for this key column.",
					"format": "uint64",
					"type": "string"
				},
				"identifiers": {
					"description": "Identifiers is the number of identifiers for this key column.",
					"format": "uint64",
					"type": "string"
				},
				"multi_value": {
					"description": "MultiValue is set to true if this is a multi-value key column.",
					"type": "boolean"
				},
				"valid_values": {
					"description": "ValidValues is the number of valid values for this key column.",
					"format": "uint64",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Datasets.CreateDatasetRequest": {
			"description": "CreateDatasetRequest is the input used by the CreateDataset rpc.",
			"properties": {
				"dataset_type": {
					"allOf": [
						{
							"$ref": "#/definitions/Datasets.DatasetType"
						}
					],
					"description": "DatasetType denotes whether the dataset is insight or activation."
				},
				"description": {
					"description": "Description is a user defined description for the dataset.\nDescription has a max length of 1000 characters.",
					"type": "string"
				},
				"expiration": {
					"allOf": [
						{
							"$ref": "#/definitions/Datasets.DatasetExpiration"
						}
					],
					"description": "Expiration specifies information about how the dataset should expire."
				},
				"private_id": {
					"description": "PrivateId is the name of the dataset visible only within the owner company, used for querying.\nPrivateIDs can only contain upper and lower case letter and numbers with a minimum length of 1,\nand a maximum length of 17.",
					"type": "string"
				},
				"public_name": {
					"description": "PublicName is the name of the dataset as seen by other companies with permission to the dataset.\nPublicNames can only contain alphanumeric (ascii) characters, including dash,\nunderscore and spaces with a max length of 100 and a minimum length of 1.",
					"type": "string"
				},
				"region": {
					"allOf": [
						{
							"$ref": "#/definitions/Datasets.Region"
						}
					],
					"description": "Region is the cloud vault region the dataset can accept input data from."
				}
			},
			"type": "object"
		},
		"Datasets.CreateDatasetResponse": {
			"description": "CreateDatasetResponse is the response for CreateDataset rpc.",
			"properties": {
				"dataset_id": {
					"description": "DatasetId is the ID assigned to the newly created dataset.",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Datasets.Dataset": {
			"description": "Dataset is the summary of a dataset returned when getting a dataset.",
			"properties": {
				"created_by": {
					"description": "CreatedBy is the user ID who creates the dataset.",
					"type": "string"
				},
				"created_date_time": {
					"description": "CreatedDateTime is the datetime that the dataset was created.",
					"format": "date-time",
					"type": "string"
				},
				"dataset_id": {
					"description": "DatasetID is the ID of the dataset.",
					"type": "string"
				},
				"dataset_type": {
					"allOf": [
						{
							"$ref": "#/definitions/Datasets.DatasetType"
						}
					],
					"title": "DatasetType is the dataset type, insight or activation"
				},
				"description": {
					"description": "Description is a user defined string to describe the dataset.",
					"type": "string"
				},
				"expiration": {
					"allOf": [
						{
							"$ref": "#/definitions/Datasets.DatasetExpiration"
						}
					],
					"description": "Expiration specifies information about how the dataset should expire."
				},
				"owner_id": {
					"description": "OwnerID is the ID of the company that owns the dataset.",
					"type": "string"
				},
				"private_id": {
					"description": "PrivateID is the private ID of the dataset.",
					"type": "string"
				},
				"public_name": {
					"description": "PublicName is the public name of the dataset.",
					"type": "string"
				},
				"publish_details": {
					"allOf": [
						{
							"$ref": "#/definitions/Datasets.ListedPublishDetails"
						}
					],
					"description": "ListedPublishDetails is the summary info for the published slot."
				},
				"published_by": {
					"description": "PublishedBy is the user ID who creates the dataset.",
					"type": "string"
				},
				"region": {
					"allOf": [
						{
							"$ref": "#/definitions/Datasets.Region"
						}
					],
					"description": "Region is the cloud vault region the dataset can accept input data from."
				}
			},
			"type": "object"
		},
		"Datasets.DatasetExpiration": {
			"description": "DatasetExpiration contains information about how a dataset should expire.",
			"properties": {
				"do_not_expire": {
					"description": "DoNotExpire sets a dataset to not expire.",
					"type": "boolean"
				},
				"expiration_date_time": {
					"description": "ExpirationDateTime is the datetime that the dataset will expire.",
					"format": "date-time",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Datasets.DatasetType": {
			"default": "DATASET_TYPE_INVALID",
			"description": "DatasetType gives the dataset type, insight or identity.\n\n - DATASET_TYPE_INVALID: Invalid is used when no other enum applies.\n - DATASET_TYPE_INSIGHT: Insight is for insight datasets.\n - DATASET_TYPE_IDENTITY: Identity is for identity (activation) datasets.",
			"enum": [
				"DATASET_TYPE_INVALID",
				"DATASET_TYPE_INSIGHT",
				"DATASET_TYPE_IDENTITY"
			],
			"type": "string"
		},
		"Datasets.DeleteDatasetResponse": {
			"description": "DeleteDatasetResponse is the response for DeleteDataset rpc.",
			"type": "object"
		},
		"Datasets.GetDatasetResponse": {
			"description": "GetDatasetResponse is the response for GetDataset rpc.",
			"properties": {
				"dataset": {
					"allOf": [
						{
							"$ref": "#/definitions/Datasets.Dataset"
						}
					],
					"description": "Dataset is summary information about the requested dataset."
				}
			},
			"type": "object"
		},
		"Datasets.ListDatasetsResponse": {
			"description": "ListDatasetsResponse is the response for ListDatasets rpc.",
			"properties": {
				"datasets": {
					"description": "Datasets is the list of datasets and their summary info.",
					"items": {
						"$ref": "#/definitions/Datasets.ListedDataset",
						"type": "object"
					},
					"type": "array"
				},
				"pagination": {
					"allOf": [
						{
							"$ref": "#/definitions/PaginationResponse"
						}
					],
					"description": "Pagination is the information on how the results were paginated."
				}
			},
			"type": "object"
		},
		"Datasets.ListedDataset": {
			"description": "ListedDataset is the summary of a dataset returned when listing datasets.",
			"properties": {
				"created_by": {
					"description": "CreatedBy is the user ID who creates the dataset.",
					"type": "string"
				},
				"created_date_time": {
					"description": "CreatedDateTime is the datetime that the dataset was created.",
					"format": "date-time",
					"type": "string"
				},
				"dataset_id": {
					"description": "DatasetID is the ID of the dataset.",
					"type": "string"
				},
				"dataset_type": {
					"allOf": [
						{
							"$ref": "#/definitions/Datasets.DatasetType"
						}
					],
					"title": "DatasetType is the dataset type, insight or activation"
				},
				"description": {
					"description": "Description is a user defined string to describe the dataset.",
					"type": "string"
				},
				"expiration": {
					"allOf": [
						{
							"$ref": "#/definitions/Datasets.DatasetExpiration"
						}
					],
					"description": "Expiration specifies information about how the dataset should expire."
				},
				"owner_id": {
					"description": "OwnerID is the ID of the company that owns the dataset.",
					"type": "string"
				},
				"private_id": {
					"description": "PrivateID is the private ID of the dataset.",
					"type": "string"
				},
				"public_name": {
					"description": "PublicName is the public name of the dataset.",
					"type": "string"
				},
				"publish_details": {
					"allOf": [
						{
							"$ref": "#/definitions/Datasets.ListedPublishDetails"
						}
					],
					"description": "ListedPublishDetails is the summary info for the published slot."
				},
				"published_by": {
					"description": "PublishedBy is the user ID who creates the dataset.",
					"type": "string"
				},
				"region": {
					"allOf": [
						{
							"$ref": "#/definitions/Datasets.Region"
						}
					],
					"description": "Region is the cloud vault region the dataset can accept input data from."
				}
			},
			"type": "object"
		},
		"Datasets.ListedPublishDetails": {
			"description": "ListedPublishDetails is a summary of info about a preparing/prepared dataset image, empty if no preparing/prepared image.",
			"properties": {
				"execution_id": {
					"description": "ExecutionID is the execution ID of the prepare that was used in the publish.",
					"type": "string"
				},
				"publish_date_time": {
					"description": "PublishDateTime is the time at which the publish took place.",
					"format": "date-time",
					"type": "string"
				},
				"recordset_id": {
					"description": "RecordsetID is the recordset ID used to execute the prepare.",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Datasets.Region": {
			"default": "UNKNOWN",
			"description": "Region enumerates the supported cloud providers and locations.\n\n - UNKNOWN: UNKNOWN means the region has not been defined.\n - AWS_EU_WEST_2: AWS_EU_WEST_2 means AWS Europe (London).\n - AWS_US_EAST_1: AWS_US_EAST_1 means AWS US East (N. Virginia).\n - IBM_EU_CENTRAL_1: IBM_EU_CENTRAL_1 means IBM MZR EU Central (Frankfurt).\n - AWS_EU_CENTRAL_1: AWS_EU_CENTRAL_1 means AWS Europe (Frankfurt).\n - AWS_AP_SOUTHEAST_2: AWS_AP_SOUTHEAST_2 means AWS Asia Pacific (Sydney)",
			"enum": [
				"UNKNOWN",
				"AWS_EU_WEST_2",
				"AWS_US_EAST_1",
				"IBM_EU_CENTRAL_1",
				"AWS_EU_CENTRAL_1",
				"AWS_AP_SOUTHEAST_2"
			],
			"type": "string"
		},
		"Datasets.UpdateDatasetResponse": {
			"description": "UpdateDatasetResponse is the response for UpdateDataset rpc.",
			"type": "object"
		},
		"Datasets.v2.UpdateDataset": {
			"description": "Dataset contains details of the update which can be partial.",
			"properties": {
				"description": {
					"description": "Description is a user defined description for the dataset.\nDescription has a max length of 1000 characters.",
					"type": "string"
				},
				"expiration": {
					"allOf": [
						{
							"$ref": "#/definitions/Datasets.DatasetExpiration"
						}
					],
					"description": "Expiration specifies information about how the dataset should expire."
				},
				"private_id": {
					"description": "PrivateId is the name of the dataset visible only within the owner company, used for querying.\nPrivateIDs can only contain upper and lower case letter and numbers with a minimum length of 1,\nand a maximum length of 17.",
					"type": "string"
				},
				"public_name": {
					"description": "PublicName is the name of the dataset as seen by other companies with permission to the dataset.\nPublicNames can only contain alphanumeric (ascii) characters, including dash,\nunderscore and spaces with a max length of 100 and a minimum length of 1.",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Destination_Instances.AttachToPermissionBody": {
			"properties": {
				"permission_id": {
					"description": "Permission ID to attach to.",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Destination_Instances.AttachToPermissionResponse": {
			"properties": {
				"permission_ids": {
					"description": "Modified list of Permissions the Destination Instance is attached to.",
					"items": {
						"type": "string"
					},
					"type": "array"
				}
			},
			"type": "object"
		},
		"Destination_Instances.CreateDestinationInstanceRequest": {
			"description": "CreateDestinationInstanceRequest contains all parameters required to create a Destination instance.",
			"properties": {
				"config": {
					"description": "Config is the config for the destination.",
					"type": "object"
				},
				"description": {
					"description": "Description is an optional description given to this destination.",
					"type": "string"
				},
				"destination_type_id": {
					"description": "DestinationTypeId is the InfoSum type ID of this destination.",
					"type": "string"
				},
				"editable_paths": {
					"description": "EditablePaths is the list of schema paths that can be edited at push time.",
					"items": {
						"type": "string"
					},
					"type": "array"
				},
				"name": {
					"description": "Name is the display name given to this destination.",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Destination_Instances.CreateDestinationInstanceResponse": {
			"description": "CreateDestinationInstanceResponse contains the Destination instance ID.",
			"properties": {
				"destination_id": {
					"description": "Destination instance ID.",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Destination_Instances.DeleteDestinationInstanceResponse": {
			"description": "DeleteDestinationInstanceResponse is currently empty.",
			"type": "object"
		},
		"Destination_Instances.DestinationInstance": {
			"description": "DestinationInstance is the information required to define a destination instance.",
			"properties": {
				"config": {
					"description": "Config is the config for the destination.",
					"type": "object"
				},
				"created_time": {
					"description": "CreatedTime is the date and time the destination was created.",
					"format": "date-time",
					"type": "string"
				},
				"creator_id": {
					"description": "CreatorId is the ID of the user who created the destination.",
					"type": "string"
				},
				"description": {
					"description": "Description is an optional description given to this destination.",
					"type": "string"
				},
				"destination_type_id": {
					"description": "DestinationTypeId is the InfoSum type ID of this destination.",
					"type": "string"
				},
				"editable_paths": {
					"description": "EditablePaths is the list of schema paths that can be edited at push time.",
					"items": {
						"type": "string"
					},
					"type": "array"
				},
				"id": {
					"description": "ID is the globally unique ID of the destination.",
					"type": "string"
				},
				"incoming_share_id": {
					"description": "IncomingShareID is the share ID granting you visibility of this destination if the destination is not owned by you.",
					"type": "string"
				},
				"name": {
					"description": "Name is the display name given to this destination.",
					"type": "string"
				},
				"outgoing_share_ids": {
					"description": "OutgoingShareIDs are the IDs of destination shares you have created to share an owned destination with others.",
					"items": {
						"type": "string"
					},
					"type": "array"
				},
				"owner_id": {
					"description": "OwnerId is the user or company ID of the owner of the destination.",
					"type": "string"
				},
				"permission_ids": {
					"description": "PermissionIDs is the list of permissions this destination instance has been attached to.",
					"items": {
						"type": "string"
					},
					"type": "array"
				},
				"permissioned_to_permitted_company": {
					"description": "PermissionedToPermittedCompany indicates that the destination has been attached to a permission to a company that was permitted by the destination share.",
					"type": "boolean"
				},
				"updated_time": {
					"description": "UpdatedTime is the date and time the destination was last updated.",
					"format": "date-time",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Destination_Instances.DestinationInstanceOverview": {
			"description": "DestinationInstanceOverview provides an overview of a Destination instance.",
			"properties": {
				"created_time": {
					"description": "CreatedTime is the date and time the destination was created. Output only.",
					"format": "date-time",
					"readOnly": true,
					"type": "string"
				},
				"creator_id": {
					"description": "CreatorId is the ID of the user who created the destination. Output only.",
					"readOnly": true,
					"type": "string"
				},
				"description": {
					"description": "Description is an optional description given to this destination.",
					"type": "string"
				},
				"destination_type_id": {
					"description": "DestinationTypeId is the InfoSum type ID of this destination.",
					"type": "string"
				},
				"id": {
					"description": "ID is the globally unique ID of the destination. Output only.",
					"readOnly": true,
					"type": "string"
				},
				"incoming_share_id": {
					"description": "IncomingShareID is the share ID granting you visibility of this destination if the destination is not owned by you.",
					"type": "string"
				},
				"name": {
					"description": "Name is the display name given to this destination.",
					"type": "string"
				},
				"outgoing_share_ids": {
					"description": "OutgoingShareIDs are the IDs of destination shares you have created to share an owned destination with others.",
					"items": {
						"type": "string"
					},
					"type": "array"
				},
				"owner_id": {
					"description": "OwnerId is the user or company ID of the owner of the destination. Output only.",
					"readOnly": true,
					"type": "string"
				},
				"permission_ids": {
					"description": "PermissionIDs is the list of permissions this destination instance has been attached to.",
					"items": {
						"type": "string"
					},
					"type": "array"
				},
				"permissioned_to_permitted_company": {
					"description": "PermissionedToPermittedCompany indicates that the destination has been attached to a permission to a company that was permitted by the destination share.",
					"type": "boolean"
				},
				"updated_time": {
					"description": "UpdatedTime is the date and time the destination was last updated. Output only.",
					"format": "date-time",
					"readOnly": true,
					"type": "string"
				}
			},
			"type": "object"
		},
		"Destination_Instances.DestinationInstanceUpdate": {
			"properties": {
				"config": {
					"description": "Complete destination config. If set, this field acts as a PUT on the underlying config. All fields must be provided even if they are unchanged in the update. The values for previously set `x-infosum-secret` properties can be retained by re-submitting the `X-INFOSUM-REDACTED` value.",
					"type": "object"
				},
				"description": {
					"description": "Description is an optional description given to this destination.",
					"type": "string"
				},
				"editable_paths": {
					"description": "EditablePaths is the list of schema paths that can be edited at push time.",
					"items": {
						"type": "string"
					},
					"type": "array",
					"x-go-type": {
						"hints": {
							"noValidation": true,
							"nullable": true
						},
						"type": "[]string"
					},
					"x-omitempty": true
				},
				"name": {
					"description": "Name is the display name given to this destination.",
					"type": "string"
				}
			},
			"title": "UpdateDestinationInstance is the input to UpdateDestination",
			"type": "object"
		},
		"Destination_Instances.DestinationTypeOverview": {
			"description": "DestinationTypeOverview contains the identifier of the type and a human readable name.",
			"properties": {
				"id": {
					"description": "Destination type identifier.",
					"type": "string"
				},
				"name": {
					"description": "Human friendly name of the Destination type.",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Destination_Instances.DetachFromPermissionBody": {
			"properties": {
				"permission_id": {
					"description": "Permission ID to detach from.",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Destination_Instances.DetachFromPermissionResponse": {
			"properties": {
				"permission_ids": {
					"description": "Modified list of Permissions the Destination Instance is attached to.",
					"items": {
						"type": "string"
					},
					"type": "array"
				}
			},
			"type": "object"
		},
		"Destination_Instances.DuplicateDestinationInstanceBody": {
			"type": "object"
		},
		"Destination_Instances.DuplicateDestinationInstanceResponse": {
			"properties": {
				"destination_id": {
					"description": "ID of the newly duplicated Destination Instance.",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Destination_Instances.GetDestinationInstanceResponse": {
			"description": "GetDestinationInstanceResponse the Destination instance details.",
			"properties": {
				"destination": {
					"allOf": [
						{
							"$ref": "#/definitions/Destination_Instances.DestinationInstance"
						}
					],
					"description": "Destination instance details."
				}
			},
			"type": "object"
		},
		"Destination_Instances.GetDestinationTypeExternalConfigResponse": {
			"description": "GetDestinationTypeExternalConfigRequest contains a JSON-object with external-config details.",
			"properties": {
				"external_config": {
					"description": "External configuration details.",
					"type": "object"
				}
			},
			"type": "object"
		},
		"Destination_Instances.GetDestinationTypeSchemaResponse": {
			"description": "GetDestinationTypeSchemaResponse is the output of the GetDestinationSchema method.",
			"properties": {
				"connection_specification": {
					"description": "JSON-Schema of the configuration required to create an instance of the requested Destination type.",
					"type": "object"
				}
			},
			"type": "object"
		},
		"Destination_Instances.ListDestinationInstancesResponse": {
			"description": "ListDestinationInstancesResponse returns a list of Destination instances overviews.",
			"properties": {
				"destinations": {
					"description": "Destinations instances overviews.",
					"items": {
						"$ref": "#/definitions/Destination_Instances.DestinationInstanceOverview",
						"type": "object"
					},
					"type": "array"
				},
				"pagination": {
					"$ref": "#/definitions/PaginationResponse"
				}
			},
			"type": "object"
		},
		"Destination_Instances.ListDestinationTypesResponse": {
			"description": "ListDestinationTypesResponse contains a list of supported Destination type names.",
			"properties": {
				"destination_types": {
					"description": "List of Destination types.",
					"items": {
						"$ref": "#/definitions/Destination_Instances.DestinationTypeOverview",
						"type": "object"
					},
					"type": "array"
				}
			},
			"type": "object"
		},
		"Destination_Instances.NullValue": {
			"default": "NULL_VALUE",
			"description": "`NullValue` is a singleton enumeration to represent the null value for the\n`Value` type union.\n\nThe JSON representation for `NullValue` is JSON `null`.\n\n - NULL_VALUE: Null value.",
			"enum": [
				"NULL_VALUE"
			],
			"type": "string"
		},
		"Destination_Instances.UpdateDestinationInstanceResponse": {
			"description": "UpdateDestinationInstanceResponse is the output of the UpdateDestinationInstance method.",
			"properties": {
				"destination": {
					"allOf": [
						{
							"$ref": "#/definitions/Destination_Instances.DestinationInstance"
						}
					],
					"description": "Destination instance details."
				}
			},
			"type": "object"
		},
		"Destination_Shares.CreateDestinationShareRequest": {
			"properties": {
				"comment": {
					"description": "An optional comment explaining why sharing this destination.",
					"type": "string"
				},
				"destination_id": {
					"description": "ID of the Destination Instance to be shared.",
					"type": "string"
				},
				"other_permitted_companies": {
					"description": "The ID of other companies that the sender of this share allows the recipient to send permissions to, with the shared destination associated. Currently these must be InfoSum company IDs. Using this field is currently only available where the sender and recipient of the destination share are managed service customers.",
					"items": {
						"type": "string"
					},
					"type": "array"
				},
				"recipient_email_address": {
					"description": "Recipient email address to be used to find company to share Destination Instance to.",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Destination_Shares.CreateDestinationShareResponse": {
			"properties": {
				"share_id": {
					"description": "ID of the created Destination Share entity.",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Destination_Shares.DestinationShare": {
			"properties": {
				"comment": {
					"description": "A comment describing the purpose of this Share by the Destination owner.",
					"type": "string"
				},
				"destination_id": {
					"description": "The destination ID of the shared instance.",
					"type": "string"
				},
				"other_permitted_companies": {
					"description": "The ID of other companies that the sender of this share allows the recipient to send permissions to, with the shared destination associated.",
					"items": {
						"type": "string"
					},
					"type": "array"
				},
				"recipient_email_address": {
					"description": "The email address of the user that was used to locate the recipient company.",
					"type": "string"
				},
				"sender_company_id": {
					"description": "The owner of the destination and granter of the share.",
					"type": "string"
				},
				"share_id": {
					"description": "The Share ID.",
					"type": "string"
				},
				"shared_at_date_time": {
					"description": "The date and time that the Destination Instance was shared.",
					"format": "date-time",
					"type": "string"
				}
			},
			"title": "DestinationShare contains details of a destination share",
			"type": "object"
		},
		"Destination_Shares.GetDestinationShareResponse": {
			"properties": {
				"destination_share": {
					"allOf": [
						{
							"$ref": "#/definitions/Destination_Shares.DestinationShare"
						}
					],
					"description": "Details of the requested Destination Share."
				}
			},
			"type": "object"
		},
		"Destination_Shares.ListDestinationSharesResponse": {
			"properties": {
				"destination_shares": {
					"description": "List of all Destination Shares both sent or received by the company of the requesting user subject to the supplied filters.",
					"items": {
						"$ref": "#/definitions/Destination_Shares.DestinationShare",
						"type": "object"
					},
					"type": "array"
				},
				"pagination": {
					"$ref": "#/definitions/PaginationResponse"
				}
			},
			"type": "object"
		},
		"Destination_Shares.RemoveDestinationShareResponse": {
			"type": "object"
		},
		"Error": {
			"description": "Error is used to define an error from an InfoSum API.",
			"properties": {
				"details": {
					"allOf": [
						{
							"$ref": "#/definitions/ErrorMessage"
						}
					],
					"description": "Details is an optional low level error which caused the request to fail.\nThis may provide the detailed information on the action or resource which caused the error."
				},
				"error": {
					"allOf": [
						{
							"$ref": "#/definitions/ErrorMessage"
						}
					],
					"description": "Error is the high level error which occurred when the service tried to action the request."
				},
				"help_url": {
					"description": "HelpUrl is an optional link to online documentation which either describes the error or provides useful\ninformation to help explain a feature and resolve the issue.",
					"type": "string"
				},
				"request_id": {
					"description": "RequestId is the id of the request which can help in diagnostics.",
					"type": "string"
				},
				"time": {
					"description": "Time is the timestamp at which the error occurred.",
					"format": "date-time",
					"type": "string"
				}
			},
			"type": "object"
		},
		"ErrorMessage": {
			"description": "ErrorMessage contains a grouping of error code and its corresponding localised message.",
			"properties": {
				"code": {
					"description": "Code is the InfoSum error code for this error.",
					"type": "string"
				},
				"message": {
					"description": "Message is the localised error message containing details of what went wrong and how to fix it.",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Files.DeleteResponse": {
			"description": "DeleteResponse is an empty response for the Delete file request.",
			"properties": {
				"files_remaining": {
					"description": "Boolean indicating if files remain at the given prefix after a bulk delete operation. This will be set to true in the case that more than 1000 files existed at the prefix requested. Call delete again with the same request until this value returns false in order to delete the entire prefix.",
					"type": "boolean"
				}
			},
			"type": "object"
		},
		"Files.File": {
			"description": "File is the entity that is the combination of file attributes and file metadata.",
			"properties": {
				"created_date_time": {
					"description": "The Cloud Vault timestamp for when this file was created.",
					"format": "date-time",
					"readOnly": true,
					"type": "string"
				},
				"metadata": {
					"allOf": [
						{
							"$ref": "#/definitions/Files.Metadata"
						}
					],
					"description": "The metadata associated with this file.",
					"readOnly": true
				},
				"name": {
					"description": "The name of the file.",
					"readOnly": true,
					"type": "string"
				},
				"size": {
					"description": "The size of the file in bytes.",
					"format": "int64",
					"readOnly": true,
					"type": "string"
				}
			},
			"type": "object"
		},
		"Files.ListResponse": {
			"description": "ListResponse is the output of the List method.",
			"properties": {
				"files": {
					"description": "Files are a list of data for files matching the list request.",
					"items": {
						"$ref": "#/definitions/Files.File",
						"type": "object"
					},
					"type": "array"
				},
				"pagination": {
					"allOf": [
						{
							"$ref": "#/definitions/PaginationResponse"
						}
					],
					"description": "Pagination is the information on how the results were paginated."
				}
			},
			"type": "object"
		},
		"Files.Metadata": {
			"description": "Metadata is the entity that contains the metadata associated with a file.",
			"properties": {
				"origin": {
					"allOf": [
						{
							"$ref": "#/definitions/Files.Origin"
						}
					],
					"description": "The details of the origin of the file.",
					"readOnly": true
				},
				"resource_type": {
					"allOf": [
						{
							"$ref": "#/definitions/Files.ResourceType"
						}
					],
					"description": "The type of resource; e.g folder, recordset or file. OUTPUT_ONLY.",
					"readOnly": true
				},
				"updated_date_time": {
					"description": "The time at which we most recently updated (or created) this Metadata.",
					"format": "date-time",
					"readOnly": true,
					"type": "string"
				}
			},
			"type": "object"
		},
		"Files.Origin": {
			"description": "Origin is the entity that contains information about the origin of a file.",
			"properties": {
				"properties": {
					"additionalProperties": {
						"type": "string"
					},
					"description": "A map of additional properties related to the creation of this file.",
					"readOnly": true,
					"type": "object"
				},
				"task_id": {
					"description": "The unique identifier of the task that caused this file to be created.",
					"readOnly": true,
					"type": "string"
				},
				"task_type": {
					"description": "The type of the task that caused this file to be created.",
					"readOnly": true,
					"type": "string"
				}
			},
			"readOnly": true,
			"type": "object"
		},
		"Files.ResourceType": {
			"default": "RESOURCE_TYPE_INVALID",
			"description": "ResourceType is the type of resource that is referred to.\nOUTPUT_ONLY.",
			"enum": [
				"RESOURCE_TYPE_INVALID",
				"FILE",
				"FOLDER",
				"RECORDSET"
			],
			"type": "string"
		},
		"GetCloudVaultResponse": {
			"properties": {
				"cloud_vault": {
					"$ref": "#/definitions/v2.CloudVault"
				}
			},
			"title": "GetCloudVaultResponse",
			"type": "object"
		},
		"GetMetadataResponse": {
			"description": "GetMetadataResponse is the details about a specific Cloud Vault.",
			"properties": {
				"metadata": {
					"$ref": "#/definitions/CloudVaultMetadata"
				}
			},
			"type": "object"
		},
		"GetRegionsResponse": {
			"description": "GetRegionsResponse is the response to GetCloudVaultRegions method.",
			"properties": {
				"region_to_cloud_vaults": {
					"additionalProperties": {
						"$ref": "#/definitions/CloudVaultsList"
					},
					"type": "object"
				}
			},
			"type": "object"
		},
		"Global_Schema.CategoriesResponse": {
			"description": "CategoriesResponse is the response from the Categories method.",
			"properties": {
				"categories": {
					"description": "Categories holds data on the categories in the global schema.",
					"items": {
						"$ref": "#/definitions/Global_Schema.Category",
						"type": "object"
					},
					"type": "array"
				},
				"pagination": {
					"allOf": [
						{
							"$ref": "#/definitions/PaginationResponse"
						}
					],
					"description": "Pagination is the pagination details of the returned categories."
				}
			},
			"type": "object"
		},
		"Global_Schema.Category": {
			"description": "Category describes a Category.",
			"properties": {
				"description": {
					"description": "Description is the Description of this Category.",
					"type": "string"
				},
				"id": {
					"description": "Id is the unique ID of this Category.",
					"format": "int64",
					"type": "string"
				},
				"key_contributor": {
					"description": "KeyContributor is a flag that shows whether the category has at least one representation\nthat contributes to a key.",
					"type": "boolean"
				},
				"name": {
					"description": "Name is the human-readable name of this Category.",
					"type": "string"
				},
				"properties": {
					"description": "Properties contain the different properties of this Category.",
					"items": {
						"$ref": "#/definitions/Global_Schema.Property",
						"type": "object"
					},
					"type": "array"
				}
			},
			"type": "object"
		},
		"Global_Schema.Key": {
			"description": "Key describes a Key.",
			"properties": {
				"categories": {
					"description": "Categories is a list of Category names and flags to indicate whether the Category is present.",
					"items": {
						"$ref": "#/definitions/Global_Schema.KeyCategory",
						"type": "object"
					},
					"type": "array"
				},
				"id": {
					"description": "ID is the unique ID of a key.",
					"format": "int64",
					"type": "string"
				},
				"name": {
					"description": "Name is the human readable name of the Key.",
					"type": "string"
				},
				"representation_version_ids": {
					"description": "RepresentationVersionIDs is a list of the representation version IDs in a specific key.",
					"items": {
						"format": "int64",
						"type": "string"
					},
					"type": "array"
				}
			},
			"type": "object"
		},
		"Global_Schema.KeyCategoriesResponse": {
			"description": "KeyCategoriesResponse is the response from the KeyCategories method.",
			"properties": {
				"categories": {
					"description": "Categories holds data on the key categories in the global schema.",
					"items": {
						"$ref": "#/definitions/Global_Schema.Category",
						"type": "object"
					},
					"type": "array"
				},
				"pagination": {
					"allOf": [
						{
							"$ref": "#/definitions/PaginationResponse"
						}
					],
					"description": "Pagination is the pagination details of the returned categories."
				}
			},
			"type": "object"
		},
		"Global_Schema.KeyCategory": {
			"description": "KeyCategory is a message to support a category name being returned as a part of the overall info\nof a Key. It will also return whether or not the category named is currently in-use or if\nit's an \"extra\" one to fulfil in the event the user wishes to use the returned key.",
			"properties": {
				"category_name": {
					"description": "CategoryName is the name a category that owns a representation involved within the Key.",
					"type": "string"
				},
				"is_present": {
					"description": "IsPresent is to determine whether or not the Category is present in the request. If not,\nthis will be used to indicate what the user is missing in order to use the Key.",
					"type": "boolean"
				}
			},
			"type": "object"
		},
		"Global_Schema.KeysResponse": {
			"description": "KeysResponse is the response from the Keys method.",
			"properties": {
				"keys": {
					"description": "Keys contains all the keys supported by the Normalizer.",
					"items": {
						"$ref": "#/definitions/Global_Schema.Key",
						"type": "object"
					},
					"type": "array"
				},
				"pagination": {
					"allOf": [
						{
							"$ref": "#/definitions/PaginationResponse"
						}
					],
					"description": "Pagination is the pagination details of the returned keys."
				}
			},
			"type": "object"
		},
		"Global_Schema.PossibleValues": {
			"description": "PossibleValues is the list of values the Property can have. It only applies if the Property\nis not a column, i.e. IsColumn is false.",
			"properties": {
				"default_value": {
					"description": "This is the default value that should be assigned if a selection is not made.",
					"type": "string"
				},
				"possible_values": {
					"description": "PossibleValues is the list of values the Property can have.",
					"items": {
						"type": "string"
					},
					"type": "array"
				}
			},
			"type": "object"
		},
		"Global_Schema.Property": {
			"description": "Property describes a configurable attribute of a category.",
			"properties": {
				"desc": {
					"description": "Desc is the description of this Property.",
					"type": "string"
				},
				"is_column": {
					"description": "IsColumn indicates whether this Property\nmaps to a single column.",
					"type": "boolean"
				},
				"name": {
					"description": "Name is the name of this Property.",
					"type": "string"
				},
				"optional": {
					"description": "Optional describes whether this Property is optional.",
					"type": "boolean"
				},
				"possible_values": {
					"allOf": [
						{
							"$ref": "#/definitions/Global_Schema.PossibleValues"
						}
					],
					"description": "PossibleValues is the list of values the Property can have. It only applies if the Property\nis not a column, i.e. IsColumn is false."
				},
				"type": {
					"allOf": [
						{
							"$ref": "#/definitions/Global_Schema.v2.Type"
						}
					],
					"description": "Type is the type of this Property."
				},
				"user_input": {
					"description": "UserInput is to determine whether to show the property to the user to set themselves.",
					"type": "boolean"
				}
			},
			"type": "object"
		},
		"Global_Schema.v2.Type": {
			"default": "TYPE_INVALID",
			"description": "Type is an enum of all the data types supported\nby the InfoSum products.\n\n - INT64: INT64 is the signed 64-bit integer type.\n - UINT64: UINT64 is the unsigned 64-bit integer type.\n - DOUBLE: DOUBLE is the floating point type.\n - TEXT: TEXT is the string type.\n - BOOLEAN: BOOLEAN is the boolean type.\n - BYTES: BYTES is the bytes type.\n - INT64RANGE: INT64RANGE is the range of signed 64-bit integers type.\n - TEXTARRAY: TEXTARRAY is the text array type.\n - INT64ARRAY: INT64ARRAY is the int64 array type.",
			"enum": [
				"TYPE_INVALID",
				"INT64",
				"UINT64",
				"DOUBLE",
				"TEXT",
				"BOOLEAN",
				"BYTES",
				"INT64RANGE",
				"TEXTARRAY",
				"INT64ARRAY"
			],
			"type": "string"
		},
		"Import_Connectors.ConnectorType": {
			"default": "CONNECTOR_TYPE_INVALID",
			"description": "ConnectorType are the possible connector types.",
			"enum": [
				"CONNECTOR_TYPE_INVALID",
				"S3_CROSS_ACCOUNT",
				"S3_ACCESS_KEYS",
				"GCS_SECRET_AUTH",
				"SFTP"
			],
			"type": "string"
		},
		"Import_Connectors.CreateImportConnectorRequest": {
			"description": "The input to the CreateImportConnector method.",
			"properties": {
				"config": {
					"allOf": [
						{
							"$ref": "#/definitions/Import_Connectors.UpsertImportConnector"
						}
					],
					"description": "The details used to create a new Import Connector Config."
				}
			},
			"type": "object"
		},
		"Import_Connectors.CreateImportConnectorResponse": {
			"description": "The response from the CreateImportConnector method.",
			"properties": {
				"config_id": {
					"description": "The ID of the Import Connector Config that has been created.",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Import_Connectors.DeleteImportConnectorResponse": {
			"description": "DeleteResponse is the output from the Delete method.",
			"type": "object"
		},
		"Import_Connectors.GCSConnector": {
			"description": "GCSConnector is the information required to define an GCS Connector.",
			"properties": {
				"bucket": {
					"description": "The name of the GCS Bucket.",
					"type": "string"
				},
				"filenames": {
					"description": "A pattern or a list of exact files, relative to the prefix, that are allowed to be imported using this Import Connector Config. For example `*.csv` will allow any file suffixed with `.csv` to be imported.",
					"items": {
						"type": "string"
					},
					"type": "array"
				},
				"prefix": {
					"description": "The prefix within the specified bucket.",
					"type": "string"
				},
				"secret_auth": {
					"allOf": [
						{
							"$ref": "#/definitions/Import_Connectors.GCSSecretAuth"
						}
					],
					"description": "Authenticate to the provided GCS bucket using GCS Secret Auth."
				}
			},
			"type": "object"
		},
		"Import_Connectors.GCSProvider": {
			"description": "GCSProvider is the information about the connector that can be returned.",
			"properties": {
				"bucket": {
					"description": "The name of the GCS Bucket.",
					"type": "string"
				},
				"filenames": {
					"description": "A pattern or a list of exact files, relative to the prefix, that are allowed to be imported using this Import Connector Config. For example `*.csv` will allow any file suffixed with `.csv` to be imported.",
					"items": {
						"type": "string"
					},
					"type": "array"
				},
				"prefix": {
					"description": "The prefix within the specified bucket.",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Import_Connectors.GCSSecretAuth": {
			"description": "GCSSecretAuth holds the GCS Credentials JSON as a string.",
			"properties": {
				"credentials_json": {
					"description": "The credentials for GCS as JSON.",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Import_Connectors.GPGDetails": {
			"description": "GPGDetails contains the details about the GPG key associated with an ICC.",
			"properties": {
				"do_not_expire": {
					"description": "Denotes if the GPG key has no expiry.",
					"type": "boolean"
				},
				"expiration_datetime": {
					"description": "The UTC time when the GPG key will expire.",
					"format": "date-time",
					"type": "string"
				},
				"public_key": {
					"description": "The public key to be used to encrypt files to be imported using this Import Connector Config.",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Import_Connectors.GPGExpiration": {
			"properties": {
				"do_not_expire": {
					"description": "Set the GPG key to never expire. This will override any datetime provided.",
					"type": "boolean"
				},
				"expiration_datetime": {
					"description": "The UTC datetime when the GPG key will expire.",
					"format": "date-time",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Import_Connectors.GetHostKeyResponse": {
			"description": "The response from the GetHostKey method.",
			"properties": {
				"host_key": {
					"description": "Returns the first valid public host key found from the specified sFTP server. Only supported key algorithms are returned. Supported algorithms are RSA, ED25519 and ECDSA.",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Import_Connectors.GetImportConnectorResponse": {
			"description": "The response from the GetImportConnector method.",
			"properties": {
				"config": {
					"allOf": [
						{
							"$ref": "#/definitions/Import_Connectors.ImportConnector"
						}
					],
					"description": "Details of the requested Import Connector Config."
				}
			},
			"type": "object"
		},
		"Import_Connectors.ImportConnector": {
			"description": "ImportConnector is the information that can be retrieved about an Import Connector Config.",
			"properties": {
				"connector_type": {
					"allOf": [
						{
							"$ref": "#/definitions/Import_Connectors.ConnectorType"
						}
					],
					"description": "The type of the Import Connector Config.",
					"readOnly": true
				},
				"created_date_time": {
					"description": "The date and time the Import Connector Config was created.",
					"format": "date-time",
					"readOnly": true,
					"type": "string"
				},
				"description": {
					"description": "An optional description given to this Import Connector Config.",
					"readOnly": true,
					"type": "string"
				},
				"gcs_connector": {
					"allOf": [
						{
							"$ref": "#/definitions/Import_Connectors.GCSProvider"
						}
					],
					"description": "Google Cloud Storage specific information.",
					"readOnly": true
				},
				"gpg": {
					"allOf": [
						{
							"$ref": "#/definitions/Import_Connectors.GPGDetails"
						}
					],
					"description": "Details about the GPG key associated with the Import Connector Config."
				},
				"id": {
					"description": "The unique ID of the Import Connector Config.",
					"readOnly": true,
					"type": "string"
				},
				"is_gpg": {
					"description": "Shows if the Import Connector Config allows import of GPG encrypted files.",
					"type": "boolean"
				},
				"name": {
					"description": "The display name given to this Import Connector Config.",
					"readOnly": true,
					"type": "string"
				},
				"owner_id": {
					"type": "string"
				},
				"s3_connector": {
					"allOf": [
						{
							"$ref": "#/definitions/Import_Connectors.S3Provider"
						}
					],
					"description": "AWS S3 specific information.",
					"readOnly": true
				},
				"sftp_connector": {
					"allOf": [
						{
							"$ref": "#/definitions/Import_Connectors.SFTPProvider"
						}
					],
					"description": "SFTP server specific information.",
					"readOnly": true
				},
				"updated_date_time": {
					"description": "The date and time the Import Connector Config was last updated.",
					"format": "date-time",
					"readOnly": true,
					"type": "string"
				},
				"user_id": {
					"description": "The ID of the user who created the Import Connector Config.",
					"readOnly": true,
					"type": "string"
				}
			},
			"type": "object"
		},
		"Import_Connectors.ListImportConnectorsResponse": {
			"description": "The response from the ListImportConnectors method.",
			"properties": {
				"configs": {
					"description": "Array of Import Connector Configs based on the request filters and sorting.",
					"items": {
						"$ref": "#/definitions/Import_Connectors.ImportConnector",
						"type": "object"
					},
					"type": "array"
				},
				"pagination": {
					"allOf": [
						{
							"$ref": "#/definitions/PaginationResponse"
						}
					],
					"description": "Pagination information for the returned list."
				}
			},
			"type": "object"
		},
		"Import_Connectors.RefreshGPGKeysBody": {
			"description": "The input to the RefreshGPGKeys method.",
			"properties": {
				"gpg_key_expiration": {
					"allOf": [
						{
							"$ref": "#/definitions/Import_Connectors.GPGExpiration"
						}
					],
					"description": "Details about the expiration for the GPG key associated with the Import Connector Config."
				}
			},
			"type": "object"
		},
		"Import_Connectors.RefreshGPGKeysResponse": {
			"description": "The output to the RefreshGPGKeys method.",
			"properties": {
				"public_key": {
					"description": "The new GPG public key attached to the Import Connector Config. Use this new public key to GPG encrypt your file(s).",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Import_Connectors.S3AccessKeysAuth": {
			"description": "S3AccessKeysAuth holds the details needed for authentication using access keys.",
			"properties": {
				"access_key_id": {
					"description": "The access key ID of the user to authenticate as.",
					"type": "string"
				},
				"secret_access_key": {
					"description": "The secret access key of the user to authenticate as.",
					"type": "string"
				},
				"session_token": {
					"description": "Optional token used by AWS to validate temporary security credentials.",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Import_Connectors.S3AccessKeysAuthDetail": {
			"description": "S3AccessKeysAuthDetail holds any auth details.",
			"type": "object"
		},
		"Import_Connectors.S3Connector": {
			"description": "S3Connector is the information required to define an S3 Connector.",
			"properties": {
				"access_keys": {
					"allOf": [
						{
							"$ref": "#/definitions/Import_Connectors.S3AccessKeysAuth"
						}
					],
					"description": "Authenticate to the provided S3 bucket using Access Keys."
				},
				"bucket": {
					"description": "The name of the S3 bucket.",
					"type": "string"
				},
				"cross_account": {
					"allOf": [
						{
							"$ref": "#/definitions/Import_Connectors.S3CrossAccountAuth"
						}
					],
					"description": "Authenticate to the provided S3 bucket using Cross Account."
				},
				"filenames": {
					"description": "A pattern or a list of exact files, relative to the prefix, that are allowed to be imported using this Import Connector Config. For example `*.csv` will allow any file suffixed with `.csv` to be imported.",
					"items": {
						"type": "string"
					},
					"type": "array"
				},
				"prefix": {
					"description": "The prefix within the specified bucket.",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Import_Connectors.S3CrossAccountAuth": {
			"description": "S3CrossAccountAuth holds the details needed for cross-account authentication.",
			"properties": {
				"external_id": {
					"description": "ExternalId is the external ID for the trust relationship.",
					"readOnly": true,
					"type": "string"
				},
				"principal": {
					"description": "Principal is the principal for the trust relationship.",
					"readOnly": true,
					"type": "string"
				},
				"session_name": {
					"description": "The identifier of the session.",
					"type": "string"
				},
				"user_arn": {
					"description": "The Amazon Resource Name (ARN) of the role to assume.",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Import_Connectors.S3Provider": {
			"description": "S3Provider is the information about the connector that can be returned.",
			"properties": {
				"access_keys": {
					"allOf": [
						{
							"$ref": "#/definitions/Import_Connectors.S3AccessKeysAuthDetail"
						}
					],
					"description": "Authenticate to the provided S3 bucket using Access Keys."
				},
				"bucket": {
					"description": "The name of the S3 Bucket.",
					"type": "string"
				},
				"cross_account": {
					"allOf": [
						{
							"$ref": "#/definitions/Import_Connectors.S3CrossAccountAuth"
						}
					],
					"description": "Authenticate to the provided S3 bucket using Cross Account."
				},
				"filenames": {
					"description": "A pattern or a list of exact files, relative to the prefix, that are allowed to be imported using this Import Connector Config. For example `*.csv` will allow any file suffixed with `.csv` to be imported.",
					"items": {
						"type": "string"
					},
					"type": "array"
				},
				"prefix": {
					"description": "The prefix within the specified bucket.",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Import_Connectors.SFTPConnector": {
			"description": "SFTPConnector is the information required to define an sFTP Connector.",
			"properties": {
				"filenames": {
					"description": "A pattern or a list of exact files, relative to the root directory, that are allowed to be imported using this Import Connector Config. For example `*.csv` will allow any file suffixed with `.csv` to be imported. The patterns '../', './' and '~/' are not supported.",
					"items": {
						"type": "string"
					},
					"type": "array"
				},
				"host": {
					"description": "The hostname or IP address of the server.",
					"type": "string"
				},
				"host_keys": {
					"description": "The public host keys of the server. Multiple keys can be supplied using new line separators. Supported algorithms are: RSA, ED25519 and ECDSA.",
					"type": "string"
				},
				"password": {
					"description": "The password of the user to authenticate as. At least one of password and private_key must be supplied.",
					"type": "string"
				},
				"port": {
					"description": "The port to access the server on. For example 22.",
					"format": "int32",
					"type": "integer"
				},
				"private_key": {
					"description": "The private ssh key of the user to authenticate as. At least one of password and private_key must be supplied. Can be provided encrypted. Supported types are: RSA, Private Key, EC, OpenSSH ECDSA, OpenSSH ED25519, OpenSSH RSA.",
					"type": "string"
				},
				"private_key_passphrase": {
					"description": "The passphrase to decrypt the private_key if it is provided encrypted.",
					"type": "string"
				},
				"root_directory": {
					"description": "The optional directory on the server to retrieve files from. If left blank this is relative to the users default directory on the sFTP server. The pattern '../' is not supported.",
					"type": "string"
				},
				"username": {
					"description": "The username of the user to authenticate as.",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Import_Connectors.SFTPProvider": {
			"description": "SFTPProvider is the information about the SFTP Connector that can be returned.",
			"properties": {
				"filenames": {
					"description": "A pattern or a list of exact files, relative to the root directory, that are allowed to be imported using this Import Connector Config. For example `*.csv` will allow any file suffixed with `.csv` to be imported. The patterns: '../', './' and '~/' are not supported.",
					"items": {
						"type": "string"
					},
					"type": "array"
				},
				"host": {
					"description": "The hostname or IP address of the server.",
					"type": "string"
				},
				"host_keys": {
					"type": "string"
				},
				"parsed_host_keys": {
					"description": "The validated and parsed public host keys.",
					"type": "string"
				},
				"port": {
					"description": "The port to access the server on. For example 22.",
					"format": "int32",
					"type": "integer"
				},
				"root_directory": {
					"description": "The optional directory on the server to retrieve files from. If left blank this is relative to the users default directory on the sFTP server. The pattern '../' is not supported.",
					"type": "string"
				},
				"username": {
					"description": "The username of the user to authenticate as.",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Import_Connectors.UpdateImportConnectorResponse": {
			"description": "The response from the UpdateImportConnector method.",
			"properties": {
				"config": {
					"allOf": [
						{
							"$ref": "#/definitions/Import_Connectors.ImportConnector"
						}
					],
					"description": "The updated Import Connector Config."
				}
			},
			"type": "object"
		},
		"Import_Connectors.UpsertImportConnector": {
			"description": "UpsertImportConnector is the entity that contains the information to define an Import Connector Config.",
			"properties": {
				"description": {
					"description": "An optional description given to this Import Connector Config.",
					"type": "string"
				},
				"gcs_connector": {
					"allOf": [
						{
							"$ref": "#/definitions/Import_Connectors.GCSConnector"
						}
					],
					"description": "Google Cloud Storage specific information."
				},
				"gpg_key_expiration": {
					"allOf": [
						{
							"$ref": "#/definitions/Import_Connectors.GPGExpiration"
						}
					],
					"description": "Details about the expiration for the GPG key associated with the Import Connector Config."
				},
				"id": {
					"description": "The unique ID of the Import Connector Config.",
					"readOnly": true,
					"type": "string"
				},
				"is_gpg": {
					"description": "Enables importing of GPG encrypted files.",
					"type": "boolean"
				},
				"name": {
					"description": "The display name given to the Import Connector Config.",
					"type": "string"
				},
				"s3_connector": {
					"allOf": [
						{
							"$ref": "#/definitions/Import_Connectors.S3Connector"
						}
					],
					"description": "AWS S3 specific information."
				},
				"sftp_connector": {
					"allOf": [
						{
							"$ref": "#/definitions/Import_Connectors.SFTPConnector"
						}
					],
					"description": "SFTP server specific information."
				}
			},
			"type": "object"
		},
		"Import_Executions.CancelImportExecutionResponse": {
			"description": "CancelImportExecutionResponse is the output from the CancelExecution method.",
			"type": "object"
		},
		"Import_Executions.ExecuteImportResponse": {
			"description": "the response from the ExecuteImport method.",
			"properties": {
				"execution_id": {
					"description": "The execution id of the running Import task.",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Import_Executions.GetImportExecutionResponse": {
			"description": "The response from the GetExecution method.",
			"properties": {
				"execution_details": {
					"allOf": [
						{
							"$ref": "#/definitions/Import_Executions.ImportExecutionDetails"
						}
					],
					"description": "Details of the requested Import execution task."
				}
			},
			"type": "object"
		},
		"Import_Executions.History": {
			"description": "Information about the status of the task.",
			"properties": {
				"date_time": {
					"description": "The date and time of this entry.",
					"format": "date-time",
					"type": "string"
				},
				"error": {
					"allOf": [
						{
							"$ref": "#/definitions/Error"
						}
					],
					"description": "The error produced by this entry entry."
				},
				"message": {
					"description": "The details of this entry.",
					"type": "string"
				},
				"status": {
					"allOf": [
						{
							"$ref": "#/definitions/Import_Executions.v1.Status"
						}
					],
					"description": "The status of the task for this entry."
				}
			},
			"type": "object"
		},
		"Import_Executions.ImportExecution": {
			"description": "Detailed information about an execution and their history.",
			"properties": {
				"cloud_vault_id": {
					"description": "The ID of the Cloud Vault used during the execution.",
					"type": "string"
				},
				"created_date_time": {
					"description": "The creation date and time of the current execution.",
					"format": "date-time",
					"type": "string"
				},
				"current_status": {
					"allOf": [
						{
							"$ref": "#/definitions/Import_Executions.v1.Status"
						}
					],
					"description": "The status of the current execution."
				},
				"id": {
					"description": "The ID of the execution.",
					"type": "string"
				},
				"import_id": {
					"description": "The ID of the import used in the execution.",
					"type": "string"
				},
				"progress": {
					"allOf": [
						{
							"$ref": "#/definitions/Import_Executions.Progress"
						}
					],
					"description": "The information of the progress of the import as whole."
				},
				"updated_date_time": {
					"description": "The date and time the execution was updated.",
					"format": "date-time",
					"type": "string"
				},
				"user_id": {
					"description": "The ID of the user who executed the import.",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Import_Executions.ImportExecutionDetails": {
			"description": "Detailed information about an execution and their history.",
			"properties": {
				"execution": {
					"allOf": [
						{
							"$ref": "#/definitions/Import_Executions.ImportExecution"
						}
					],
					"description": "Global information about a execution."
				},
				"history": {
					"description": "The status history of the execution execution.",
					"items": {
						"$ref": "#/definitions/Import_Executions.History",
						"type": "object"
					},
					"type": "array"
				}
			},
			"type": "object"
		},
		"Import_Executions.ListImportExecutionsResponse": {
			"description": "The response from the ListExecutions method.",
			"properties": {
				"executions": {
					"description": "A list of Import execution tasks.",
					"items": {
						"$ref": "#/definitions/Import_Executions.ImportExecution",
						"type": "object"
					},
					"type": "array"
				},
				"pagination": {
					"allOf": [
						{
							"$ref": "#/definitions/PaginationResponse"
						}
					],
					"description": "Pagination information for the returned list."
				}
			},
			"type": "object"
		},
		"Import_Executions.Progress": {
			"description": "The information of the progress of the import execution as a whole.",
			"properties": {
				"completion_percentage": {
					"description": "The current transferred bytes as a percentage.",
					"format": "float",
					"type": "number"
				},
				"speed": {
					"description": "The transferred average number of bytes per second.",
					"format": "int64",
					"type": "string"
				},
				"total_bytes": {
					"description": "The total number of bytes to be transferred.",
					"format": "int64",
					"type": "string"
				},
				"transferred_bytes": {
					"description": "The current transferred number of bytes.",
					"format": "int64",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Import_Executions.v1.Status": {
			"default": "NO_STATUS",
			"description": "Status is an enum of the different states that an async task can be in.",
			"enum": [
				"NO_STATUS",
				"WAITING",
				"INITIALIZING",
				"RUNNING",
				"FAILED",
				"COMPLETED",
				"CANCELING",
				"CANCELED",
				"STALE",
				"PROVISIONING",
				"PROVISIONED",
				"PARTIALLY_COMPLETED"
			],
			"type": "string"
		},
		"Importers.CreateImportRequest": {
			"description": "The input to the CreateImport method.",
			"properties": {
				"import": {
					"allOf": [
						{
							"$ref": "#/definitions/Importers.Import"
						}
					],
					"description": "The configuration to create a new Import with."
				}
			},
			"type": "object"
		},
		"Importers.CreateImportResponse": {
			"description": "The response from the CreateImport method.",
			"properties": {
				"import_id": {
					"description": "The ID of the Import that has been created.",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Importers.DataFilter": {
			"description": "The information about the filter for data from an import connector.",
			"properties": {
				"filter": {
					"description": "An array of strings used to filter the data from the import connector. No filter == *",
					"items": {
						"type": "string"
					},
					"type": "array"
				}
			},
			"type": "object"
		},
		"Importers.DeleteImportResponse": {
			"description": "DeleteImportResponse is the output from the Delete method.",
			"type": "object"
		},
		"Importers.GetImportResponse": {
			"description": "The response from the GetImport method.",
			"properties": {
				"import": {
					"allOf": [
						{
							"$ref": "#/definitions/Importers.Import"
						}
					],
					"description": "The configuration of the Import that was requested."
				}
			},
			"type": "object"
		},
		"Importers.Import": {
			"description": "The information required to define an import.",
			"properties": {
				"cloud_vault_id": {
					"description": "The identifier for the Cloud Vault to where the files will be imported.",
					"type": "string"
				},
				"created_date_time": {
					"description": "The date and time the import was created.",
					"format": "date-time",
					"readOnly": true,
					"type": "string"
				},
				"data_filter": {
					"allOf": [
						{
							"$ref": "#/definitions/Importers.DataFilter"
						}
					],
					"description": "The filtered data to import from the import connector."
				},
				"description": {
					"description": "A description for the import.",
					"type": "string"
				},
				"icc_id": {
					"description": "The id of the import connector config used by the import.",
					"type": "string"
				},
				"id": {
					"description": "The globally unique ID of the import.",
					"readOnly": true,
					"type": "string"
				},
				"name": {
					"description": "The name given to the import.",
					"type": "string"
				},
				"owner_id": {
					"type": "string"
				},
				"target_folder": {
					"description": "The target folder for the import. This field can be a path containing subfolders. Valid characters are alphanumeric, '_', '-', '.', '/'. This field cannot start or end with a '/'. The 'Recordsets' folder cannot be imported into. This field will be mandatory in the near future.",
					"type": "string"
				},
				"updated_date_time": {
					"description": "The date and time the import was last updated.",
					"format": "date-time",
					"readOnly": true,
					"type": "string"
				},
				"user_id": {
					"description": "The id of the user who created the import.",
					"readOnly": true,
					"type": "string"
				}
			},
			"type": "object"
		},
		"Importers.ListImportsResponse": {
			"description": "The response from the ListImports method.",
			"properties": {
				"imports": {
					"description": "A list of configurations of Imports.",
					"items": {
						"$ref": "#/definitions/Importers.Import",
						"type": "object"
					},
					"type": "array"
				},
				"pagination": {
					"allOf": [
						{
							"$ref": "#/definitions/PaginationResponse"
						}
					],
					"description": "Pagination information for the returned list."
				}
			},
			"type": "object"
		},
		"Importers.UpdateImportResponse": {
			"description": "The response from the UpdateImport method.",
			"properties": {
				"import": {
					"allOf": [
						{
							"$ref": "#/definitions/Importers.Import"
						}
					],
					"description": "he configuration of the Import that was updated."
				}
			},
			"type": "object"
		},
		"Imports.CancelResponse": {
			"description": "CancelResponse is the output from the Cancel method.",
			"type": "object"
		},
		"Imports.CreateRequest": {
			"description": "The request body to create a new local file upload.",
			"properties": {
				"cloud_vault_id": {
					"description": "The Cloud Vault ID to upload a local file to.",
					"type": "string"
				},
				"contents_sha256_checksum": {
					"description": "The SHA256 checksum of the file being uploaded.",
					"type": "string"
				},
				"target_filepath": {
					"description": "The path within the Cloud Vault of the uploaded file.",
					"type": "string"
				}
			},
			"required": [
				"cloud_vault_id",
				"target_filepath",
				"contents_sha256_checksum"
			],
			"type": "object"
		},
		"Imports.CreateResponse": {
			"description": "The response to the Create import upload request.",
			"properties": {
				"headers": {
					"additionalProperties": {
						"type": "string"
					},
					"description": "Additional HTTP headers that must be set when using the upload URL.",
					"type": "object"
				},
				"local_file_upload_id": {
					"description": "The ID of the local file upload task.",
					"type": "string"
				},
				"upload_url": {
					"description": "The temporary upload URL the user will upload their file body to.",
					"type": "string"
				},
				"upload_url_expiration_time": {
					"description": "The expiration date time of the temporary upload URL.",
					"format": "date-time",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Imports.GetResponse": {
			"description": "The response from the Get method.",
			"properties": {
				"local_file_upload_details": {
					"allOf": [
						{
							"$ref": "#/definitions/Imports.LocalFileUploadDetails"
						}
					],
					"description": "Details of the requested local file upload task."
				}
			},
			"type": "object"
		},
		"Imports.History": {
			"description": "Information about the status of the local file upload task.",
			"properties": {
				"date_time": {
					"description": "The date and time of this entry.",
					"format": "date-time",
					"type": "string"
				},
				"details": {
					"description": "The details of this entry.",
					"type": "string"
				},
				"error": {
					"allOf": [
						{
							"$ref": "#/definitions/Error"
						}
					],
					"description": "The error produced by this entry entry."
				},
				"status": {
					"allOf": [
						{
							"$ref": "#/definitions/Imports.v1.Status"
						}
					],
					"description": "The status of the local file upload task for this entry."
				}
			},
			"type": "object"
		},
		"Imports.ListResponse": {
			"description": "The response from the List method.",
			"properties": {
				"local_file_uploads": {
					"description": "A list of local file upload tasks.",
					"items": {
						"$ref": "#/definitions/Imports.LocalFileUpload",
						"type": "object"
					},
					"type": "array"
				},
				"pagination": {
					"allOf": [
						{
							"$ref": "#/definitions/PaginationResponse"
						}
					],
					"description": "Pagination information for the returned list."
				}
			},
			"type": "object"
		},
		"Imports.LocalFileUpload": {
			"description": "Information about a local file upload.",
			"properties": {
				"cloud_vault_id": {
					"description": "The identifier for the Cloud Vault where the local file will be uploaded to.",
					"type": "string"
				},
				"created_date_time": {
					"description": "The creation date and time of the local file upload.",
					"format": "date-time",
					"type": "string"
				},
				"current_status": {
					"allOf": [
						{
							"$ref": "#/definitions/Imports.v1.Status"
						}
					],
					"description": "The status of the local file upload."
				},
				"id": {
					"description": "The ID of the local file upload.",
					"type": "string"
				},
				"target_filepath": {
					"description": "The path within the Cloud Vault of the uploaded file.",
					"type": "string"
				},
				"updated_date_time": {
					"description": "The date and time the local file upload was last updated.",
					"format": "date-time",
					"type": "string"
				},
				"user_id": {
					"description": "The ID of the user who performed the local file upload.",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Imports.LocalFileUploadDetails": {
			"description": "Detailed information about a local file upload and its history.",
			"properties": {
				"history": {
					"description": "The status history of the local file upload.",
					"items": {
						"$ref": "#/definitions/Imports.History",
						"type": "object"
					},
					"type": "array"
				},
				"local_file_upload": {
					"allOf": [
						{
							"$ref": "#/definitions/Imports.LocalFileUpload"
						}
					],
					"description": "Information about the local file upload."
				}
			},
			"type": "object"
		},
		"Imports.v1.Status": {
			"default": "NO_STATUS",
			"description": "Status is an enum of the different states that an async task can be in.",
			"enum": [
				"NO_STATUS",
				"WAITING",
				"INITIALIZING",
				"RUNNING",
				"FAILED",
				"COMPLETED",
				"CANCELING",
				"CANCELED",
				"STALE",
				"PROVISIONING",
				"PROVISIONED",
				"PARTIALLY_COMPLETED"
			],
			"type": "string"
		},
		"Normalization_Config.Bounds": {
			"description": "Bounds is a pair of int64 values to specify an individual range.",
			"properties": {
				"lower": {
					"description": "Lower is the lower value of the bounds.",
					"format": "int64",
					"type": "string"
				},
				"upper": {
					"description": "Upper is the upper value of the bounds.",
					"format": "int64",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Normalization_Config.CategoryInstruction": {
			"description": "CategoryInstruction defines the input and configuration of a single category\ntype, including all of the steps required to transform the source data into\nthe category.",
			"properties": {
				"category_id": {
					"description": "CategoryId is the unique ID of this Category.",
					"format": "int64",
					"type": "string"
				},
				"column_type": {
					"additionalProperties": {
						"$ref": "#/definitions/Normalization_Config.v2.Type"
					},
					"description": "ColumnType is a mapping of column name to column type.",
					"type": "object"
				},
				"columns": {
					"description": "Columns describe the columns to read from the intermediate database.",
					"items": {
						"type": "string"
					},
					"type": "array"
				},
				"conversion_delimiter": {
					"description": "ConversionDelimiter indicates the delimiter for splitting a field.",
					"type": "string"
				},
				"convert_to_multivalue": {
					"description": "ConvertToMultivalue indicates if a column needs to be converted prior being\nassigned as multi_value.",
					"type": "boolean"
				},
				"custom_category_def": {
					"allOf": [
						{
							"$ref": "#/definitions/Normalization_Config.CustomCategory"
						}
					],
					"description": "CustomCategoryDef is a custom category creation request to make a custom\ncategory."
				},
				"ignore_warnings": {
					"description": "IgnoreWarnings specifies that any warnings occurring on this category\nshould be ignored.",
					"type": "boolean"
				},
				"mappings": {
					"description": "Mappings is a list of value mappings which can be referenced during\nnormalization.",
					"items": {
						"$ref": "#/definitions/Normalization_Config.Mapping",
						"type": "object"
					},
					"type": "array"
				},
				"properties": {
					"additionalProperties": {
						"$ref": "#/definitions/Normalization_Config.v2.Value"
					},
					"description": "Properties is a map of the parameters to the categorizer plugin.",
					"type": "object"
				},
				"script": {
					"description": "Script is the DTL script for this Categorizer.",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Normalization_Config.CategoryType": {
			"description": "CategoryType describes the types supported by custom categories and their\nrepresentation.",
			"properties": {
				"int_set": {
					"allOf": [
						{
							"$ref": "#/definitions/Normalization_Config.IntSet"
						}
					],
					"description": "IntSet contains a list of integer values that make up a representation."
				},
				"integer_lists": {
					"allOf": [
						{
							"$ref": "#/definitions/Normalization_Config.IntegerList"
						}
					],
					"description": "IntegerLists contains a list of integer values that make up a\nrepresentation."
				},
				"integer_ranges": {
					"allOf": [
						{
							"$ref": "#/definitions/Normalization_Config.IntegerRange"
						}
					],
					"description": "IntegerRanges contains a list of ranges that make up the overall range\nof a representation."
				},
				"integer_values": {
					"description": "IntegerValues allows representations to indicate that they support any\nunique integer value.",
					"properties": {},
					"type": "object"
				},
				"string_lists": {
					"allOf": [
						{
							"$ref": "#/definitions/Normalization_Config.StringList"
						}
					],
					"description": "StringLists contains a list of string values that make up a\nrepresentation."
				},
				"string_set": {
					"allOf": [
						{
							"$ref": "#/definitions/Normalization_Config.StringSet"
						}
					],
					"description": "StringSet contains a set of string values that make up a\nrepresentation."
				},
				"string_values": {
					"allOf": [
						{
							"$ref": "#/definitions/Normalization_Config.StringValue"
						}
					],
					"description": "StringValues allows representations to indicate that they support any\nunique string value."
				}
			},
			"type": "object"
		},
		"Normalization_Config.Config": {
			"description": "Config configures a normalization task.",
			"properties": {
				"categories": {
					"description": "Categories describes how the input data will be normalized into\ncategories. This will contain all categories when in an INSIGHT bunker.\nWhen it is an IDENTITY bunker, only categories that have one or more\nrepresentations that contribute to a key can be included in this list.\n\n(armory.RunConfig.categories)",
					"items": {
						"$ref": "#/definitions/Normalization_Config.CategoryInstruction",
						"type": "object"
					},
					"type": "array"
				},
				"identities": {
					"description": "Identities are the columns selected to be used to represent the identity\ncolumns in an Identity bunker. This can only be populated if the bunker\nis an IDENTITY bunker, otherwise consider it an error.\n\n(armory.RunConfig.output_data)",
					"items": {
						"type": "string"
					},
					"type": "array"
				},
				"ignored_columns": {
					"description": "IgnoredColumns specify column names that should be ignored when reading\nfrom the source data.\n\n(armory.RunConfig.ignored_columns)",
					"items": {
						"type": "string"
					},
					"type": "array"
				},
				"incremental": {
					"allOf": [
						{
							"$ref": "#/definitions/Normalization_Config.IncrementalInstruction"
						}
					],
					"description": "Incremental describes whether this request is for an incremental import and\nspecifies the column names used for extracting incremental configuration\nfields per row.\n\n(armory.RunConfig.incremental)"
				},
				"redaction_threshold": {
					"description": "RedactionThreshold corresponds to the minimum number of results required\nfor a bin to be included in the results returned.\n\n(armory.GlobalConfig.redaction_threshold)",
					"format": "int64",
					"type": "integer"
				},
				"rounding_threshold": {
					"description": "RoundingThreshold is the number that bin counts will be rounded down by.\n\n(armory.GlobalConfig.rounding_threshold)",
					"format": "int64",
					"type": "integer"
				},
				"selected_key_ids": {
					"description": "SelectedKeyIds is a list of key IDs that have been selected by the user to\ntake priority over other key ranking systems.\n\n(armory.RunConfig.selected_key_ids)",
					"items": {
						"format": "int64",
						"type": "string"
					},
					"type": "array"
				}
			},
			"type": "object"
		},
		"Normalization_Config.ConfigEntity": {
			"description": "ConfigEntity holds all the information regarding a normalisation config.",
			"properties": {
				"created_date_time": {
					"description": "CreatedDateTime is the time that this Config was created and stored.",
					"format": "date-time",
					"type": "string"
				},
				"description": {
					"description": "Description is the description given to the config to help identify what exactly is being\nstored within the config.",
					"type": "string"
				},
				"id": {
					"description": "ID is the ID of the config.",
					"type": "string"
				},
				"name": {
					"description": "Name is the name given to the config.",
					"type": "string"
				},
				"normalization_config": {
					"$ref": "#/definitions/Normalization_Config.Config"
				},
				"updated_date_time": {
					"description": "UpdatedDateTime is the last time that this Config was updated and stored.",
					"format": "date-time",
					"type": "string"
				},
				"user_id": {
					"description": "UserId is the ID of the user that created the config.",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Normalization_Config.ConfigSummary": {
			"description": "ConfigSummary has the information about a config but not the config itself.",
			"properties": {
				"created_date_time": {
					"description": "CreatedDateTime is the time that this Config was created and stored.",
					"format": "date-time",
					"type": "string"
				},
				"description": {
					"description": "Description is the description given to the config to help identify what exactly is being\nstored within the config.",
					"type": "string"
				},
				"id": {
					"description": "ID is the ID of the config.",
					"type": "string"
				},
				"name": {
					"description": "Name is the name given to the config.",
					"type": "string"
				},
				"updated_date_time": {
					"description": "UpdatedDateTime is the last time that this Config was updated and stored.",
					"format": "date-time",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Normalization_Config.CreateConfigRequest": {
			"properties": {
				"description": {
					"description": "Description is the given description for the config.",
					"type": "string"
				},
				"name": {
					"description": "Name is the name given to the config.",
					"type": "string"
				},
				"normalization_config": {
					"allOf": [
						{
							"$ref": "#/definitions/Normalization_Config.Config"
						}
					],
					"description": "Config is the normalization configuration defined by the user."
				}
			},
			"title": "CreateConfigRequest creates a new config",
			"type": "object"
		},
		"Normalization_Config.CreateConfigResponse": {
			"properties": {
				"id": {
					"title": "ID is the globally unique ID for the config",
					"type": "string"
				}
			},
			"title": "CreateConfigResponse is the response object for rpc CreateConfigRequest",
			"type": "object"
		},
		"Normalization_Config.CustomCategory": {
			"description": "CustomCategory defines a custom category definition.",
			"properties": {
				"is_key": {
					"description": "IsKey is a flag to indicate whether this custom category should be used as\na custom key.",
					"type": "boolean"
				},
				"name": {
					"description": "Name is the name of this Category.",
					"type": "string"
				},
				"type": {
					"allOf": [
						{
							"$ref": "#/definitions/Normalization_Config.CategoryType"
						}
					],
					"description": "Type describes the types supported by this Category."
				}
			},
			"type": "object"
		},
		"Normalization_Config.DeleteConfigResponse": {
			"description": "DeleteConfigResponse is the empty response of the DeleteConfig rpc.",
			"type": "object"
		},
		"Normalization_Config.GetConfigResponse": {
			"description": "GetConfigResponse is the response of the GetConfig rpc.",
			"properties": {
				"config": {
					"allOf": [
						{
							"$ref": "#/definitions/Normalization_Config.ConfigEntity"
						}
					],
					"description": "Config is the normalisation configuration that was requested."
				}
			},
			"type": "object"
		},
		"Normalization_Config.IncrementalInstruction": {
			"description": "IncrementalInstruction defines how incremental fields should be extracted\nfrom row columns.",
			"properties": {
				"full_refresh": {
					"description": "FullRefresh indicates whether this incremental run should fully refresh the\nitems in the db.",
					"type": "boolean"
				},
				"primary_key_columns": {
					"description": "PrimaryKeyColumns specifies one or more column names used for building a\nprimary key.",
					"items": {
						"type": "string"
					},
					"type": "array"
				},
				"ttl_column": {
					"description": "TTLColumn specifies an integer column used to specify a timestamp after\nwhich the row will expire.",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Normalization_Config.Int64Array": {
			"description": "Int64Array represents an array of int64 values.",
			"properties": {
				"values": {
					"description": "values represents the actual values within the array.",
					"items": {
						"format": "int64",
						"type": "string"
					},
					"type": "array"
				}
			},
			"type": "object"
		},
		"Normalization_Config.Int64Range": {
			"description": "Int64Range represents an int64 range value.",
			"properties": {
				"lower": {
					"description": "lower represents the inclusive lower bound of the range.",
					"format": "int64",
					"type": "string"
				},
				"upper": {
					"description": "upper represents the exclusive upper bound of the range.",
					"format": "int64",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Normalization_Config.IntSet": {
			"description": "IntSet contains a set of int64 values that make up a representation.",
			"properties": {
				"values": {
					"description": "Values is a list of integers that make up the IntSet message.",
					"items": {
						"format": "int64",
						"type": "string"
					},
					"type": "array"
				}
			},
			"type": "object"
		},
		"Normalization_Config.IntegerList": {
			"description": "IntegerList contains a list of integer values that make up a\nrepresentation.",
			"properties": {
				"values": {
					"description": "Values is a list of integers that make up the IntegerList message.",
					"items": {
						"format": "int64",
						"type": "string"
					},
					"type": "array"
				}
			},
			"type": "object"
		},
		"Normalization_Config.IntegerRange": {
			"description": "IntegerRange contains a list of ranges that make up the overall range of\na representation.",
			"properties": {
				"ranges": {
					"description": "Ranges is a list of Bounds that make up the overall range\nrepresentation.",
					"items": {
						"$ref": "#/definitions/Normalization_Config.Bounds",
						"type": "object"
					},
					"type": "array"
				}
			},
			"type": "object"
		},
		"Normalization_Config.ListConfigsResponse": {
			"description": "ListConfigsResponse is the response of the ListConfigs rpc.",
			"properties": {
				"configs": {
					"description": "Configs is a list of normalization configurations.",
					"items": {
						"$ref": "#/definitions/Normalization_Config.ConfigSummary",
						"type": "object"
					},
					"type": "array"
				},
				"pagination": {
					"allOf": [
						{
							"$ref": "#/definitions/PaginationResponse"
						}
					],
					"description": "Pagination is the pagination details of the returned transforms."
				}
			},
			"type": "object"
		},
		"Normalization_Config.Mapping": {
			"description": "Mapping is a uniquely-identified value map which can be referenced during\nnormalization.",
			"properties": {
				"elements": {
					"description": "elements is the list of key-value pairs which form the mapping.",
					"items": {
						"$ref": "#/definitions/Normalization_Config.Pair",
						"type": "object"
					},
					"type": "array"
				},
				"id": {
					"description": "id is the unique identifier of the mapping.",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Normalization_Config.Null": {
			"description": "Null is an enum used to map values to JSON null.",
			"type": "object"
		},
		"Normalization_Config.Pair": {
			"description": "Pair is a key-value pair describing a single element of a mapping.",
			"properties": {
				"key": {
					"allOf": [
						{
							"$ref": "#/definitions/Normalization_Config.v2.Value"
						}
					],
					"description": "Key is the key of the Pair."
				},
				"value": {
					"allOf": [
						{
							"$ref": "#/definitions/Normalization_Config.v2.Value"
						}
					],
					"description": "Value is the value of the Pair."
				}
			},
			"type": "object"
		},
		"Normalization_Config.StringList": {
			"description": "StringList contains a list of string values that make up a\nrepresentation.",
			"properties": {
				"values": {
					"description": "Values is a list of strings that make up the StringList message.",
					"items": {
						"type": "string"
					},
					"type": "array"
				}
			},
			"type": "object"
		},
		"Normalization_Config.StringSet": {
			"description": "StringSet contains a set of string values that make up a representation.",
			"properties": {
				"validator": {
					"allOf": [
						{
							"$ref": "#/definitions/Normalization_Config.StringSet.Validator"
						}
					],
					"description": "Validator is an optional regex to give structured format to an\notherwise free datatype. Examples include email formats, credit card\nnumbers or phone numbers."
				},
				"values": {
					"description": "Values is a list of strings that make up the StringSet message.",
					"items": {
						"type": "string"
					},
					"type": "array"
				}
			},
			"type": "object"
		},
		"Normalization_Config.StringSet.Validator": {
			"description": "Validator contains a validation string and a warning in the case when a\nstring fails validation.",
			"properties": {
				"validation": {
					"description": "Validation is the string to create the regex itself for validation.",
					"type": "string"
				},
				"warning": {
					"description": "Warning is the string used to inform a user the way in which they can\nfix the failed validation.",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Normalization_Config.StringValue": {
			"description": "StringValue allows representations to indicate that they support any\nunique string value. Validation can be given in the form of a regex and\nto make sure unique strings adhere to a particular format. An example\nwould be email address or credit card numbers.",
			"properties": {
				"validator": {
					"allOf": [
						{
							"$ref": "#/definitions/Normalization_Config.StringValue.Validator"
						}
					],
					"description": "Validator is an optional regex to give structured format to an\notherwise free datatype. Examples include email formats, credit card\nnumbers or phone numbers."
				}
			},
			"type": "object"
		},
		"Normalization_Config.StringValue.Validator": {
			"description": "Validator contains a validation string and a warning in the case when a\nstring fails validation.",
			"properties": {
				"validation": {
					"description": "Validation is the string to create the regex itself for validation.",
					"type": "string"
				},
				"warning": {
					"description": "Warning is the string used to inform a user the way in which they can\nfix the failed validation.",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Normalization_Config.TextArray": {
			"description": "TextArray represents an array of string values.",
			"properties": {
				"values": {
					"description": "values represents the actual values within the array.",
					"items": {
						"type": "string"
					},
					"type": "array"
				}
			},
			"type": "object"
		},
		"Normalization_Config.v2.Type": {
			"default": "TYPE_INVALID",
			"description": "Type is an enum of all the data types supported\nby the InfoSum products.\n\n - INT64: INT64 is the signed 64-bit integer type.\n - UINT64: UINT64 is the unsigned 64-bit integer type.\n - DOUBLE: DOUBLE is the floating point type.\n - TEXT: TEXT is the string type.\n - BOOLEAN: BOOLEAN is the boolean type.\n - BYTES: BYTES is the bytes type.\n - INT64RANGE: INT64RANGE is the range of signed 64-bit integers type.\n - TEXTARRAY: TEXTARRAY is the text array type.\n - INT64ARRAY: INT64ARRAY is the int64 array type.",
			"enum": [
				"TYPE_INVALID",
				"INT64",
				"UINT64",
				"DOUBLE",
				"TEXT",
				"BOOLEAN",
				"BYTES",
				"INT64RANGE",
				"TEXTARRAY",
				"INT64ARRAY"
			],
			"type": "string"
		},
		"Normalization_Config.v2.Value": {
			"description": "Value represents an item in a database row.",
			"properties": {
				"bool": {
					"description": "Represents a boolean value.",
					"type": "boolean"
				},
				"bytes": {
					"description": "Represents an array of bytes.",
					"format": "byte",
					"type": "string"
				},
				"double": {
					"description": "Represents a double value.",
					"format": "double",
					"type": "number"
				},
				"int64": {
					"description": "Represents an int64 value.",
					"format": "int64",
					"type": "string"
				},
				"int64array": {
					"allOf": [
						{
							"$ref": "#/definitions/Normalization_Config.Int64Array"
						}
					],
					"description": "Represents an array of int64 values."
				},
				"int64range": {
					"allOf": [
						{
							"$ref": "#/definitions/Normalization_Config.Int64Range"
						}
					],
					"description": "Represents a range of int64 values."
				},
				"null": {
					"allOf": [
						{
							"$ref": "#/definitions/Normalization_Config.Null"
						}
					],
					"description": "Represents a null value."
				},
				"text": {
					"description": "Represents a string value.",
					"type": "string"
				},
				"textarray": {
					"allOf": [
						{
							"$ref": "#/definitions/Normalization_Config.TextArray"
						}
					],
					"description": "Represents an array of string values."
				},
				"uint64": {
					"description": "Represents an uint64 value.",
					"format": "uint64",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Normalizations.CancelNormalizationResponse": {
			"description": "CancelNormalizationResponse is the empty response for the CancelNormalization rpc.",
			"type": "object"
		},
		"Normalizations.GetNormalizationResponse": {
			"description": "GetNormalizationResponse is the response for the GetNormalization rpc.",
			"properties": {
				"normalization_details": {
					"allOf": [
						{
							"$ref": "#/definitions/Normalizations.NormalizationDetails"
						}
					],
					"description": "NormalizationDetails holds all information on the normalization as well as the shards being used to process the\nnormalization."
				}
			},
			"type": "object"
		},
		"Normalizations.History": {
			"description": "History holds information about the status of a normalization execution.",
			"properties": {
				"date_time": {
					"description": "DateTime is the created time of the shard.",
					"format": "date-time",
					"type": "string"
				},
				"error": {
					"allOf": [
						{
							"$ref": "#/definitions/Error"
						}
					],
					"description": "Error is the error encountered by the execution shard."
				},
				"message": {
					"description": "Message is the reported message or error with status change.",
					"type": "string"
				},
				"status": {
					"allOf": [
						{
							"$ref": "#/definitions/Normalizations.v1.Status"
						}
					],
					"description": "Status is the status of the normalization execution shard."
				}
			},
			"type": "object"
		},
		"Normalizations.ListNormalizationsResponse": {
			"description": "ListNormalizationsResponse is the response of the ListNormalization rpc.",
			"properties": {
				"normalizations": {
					"description": "Normalizations is a list of the normalization records for a particular list request.",
					"items": {
						"$ref": "#/definitions/Normalizations.Normalization",
						"type": "object"
					},
					"type": "array"
				},
				"pagination": {
					"allOf": [
						{
							"$ref": "#/definitions/PaginationResponse"
						}
					],
					"description": "Pagination is the pagination details of the returned transforms."
				}
			},
			"type": "object"
		},
		"Normalizations.Normalization": {
			"description": "Normalization holds global information about a normalization.",
			"properties": {
				"cloud_vault_id": {
					"description": "CloudVaultId is the id of the Cloud Vault having source and destination\nfile(s).",
					"type": "string"
				},
				"config_id": {
					"description": "ConfigID is the ID of the normalization configuration used.\n\nreserved 4;\n reserved 5;",
					"type": "string"
				},
				"created_date_time": {
					"description": "CreatedDateTime is the creation date and time of the normalization.",
					"format": "date-time",
					"type": "string"
				},
				"current_status": {
					"allOf": [
						{
							"$ref": "#/definitions/Normalizations.v1.Status"
						}
					],
					"description": "CurrentStatus is the latest status of the normalization aggregated from its\nconstituent shards statuses."
				},
				"id": {
					"description": "Id is the ID of the normalization.",
					"type": "string"
				},
				"input_recordset_id": {
					"description": "InputRecordsetId returns the id of the input recordset.",
					"type": "string"
				},
				"output_recordset_id": {
					"description": "OutputRecordsetId returns the id of the output recordset.",
					"type": "string"
				},
				"output_recordset_name": {
					"description": "OutputRecordsetName returns the name of the output recordset.",
					"type": "string"
				},
				"processing_speed": {
					"description": "ProcessingSpeed is the number of shards the user wants to use for the normalization request.",
					"format": "int64",
					"type": "integer"
				},
				"progress": {
					"allOf": [
						{
							"$ref": "#/definitions/Normalizations.Progress"
						}
					],
					"description": "reserved 13;",
					"title": "Progress holds information on the overall progress of a normalize"
				},
				"updated_date_time": {
					"description": "UpdatedDateTime is the latest date and time any normalization shards were\nupdated.",
					"format": "date-time",
					"type": "string"
				},
				"user_id": {
					"description": "UserId is the ID of the user who created the normalization.\n\nreserved 8;",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Normalizations.NormalizationDetails": {
			"description": "NormalizationDetails holds the detailed information of a normalization.",
			"properties": {
				"history": {
					"description": "History holds a list of the state transitions and the corresponding progress and time of update.",
					"items": {
						"$ref": "#/definitions/Normalizations.History",
						"type": "object"
					},
					"type": "array"
				},
				"normalization": {
					"allOf": [
						{
							"$ref": "#/definitions/Normalizations.Normalization"
						}
					],
					"description": "Normalization holds the information on a normalization."
				}
			},
			"type": "object"
		},
		"Normalizations.NormalizeRequest": {
			"description": "NormalizeRequest is used to start a normalization.",
			"properties": {
				"cloud_vault_id": {
					"description": "CloudVaultID is the ID of the Cloud Vault to perform the normalization in.\n\nreserved 3;",
					"type": "string"
				},
				"input_recordset_id": {
					"description": "InputRecordsetID specifies the input as a recordset.\n\nreserved 5;",
					"type": "string"
				},
				"normalization_config_id": {
					"description": "NormalizationConfigID is the ID of the Normalization Config the user wants to use to normalize the input files.",
					"type": "string"
				},
				"output_recordset_name": {
					"description": "OutputRecordsetName specifies the name of the output recordset.",
					"type": "string"
				},
				"processing_speed": {
					"description": "ProcessingSpeed is the number of shards the user wants to use for the normalization request.\n\nreserved 7;",
					"format": "int64",
					"type": "integer"
				}
			},
			"type": "object"
		},
		"Normalizations.NormalizeResponse": {
			"description": "NormalizeResponse provides the normalization ID for tracking.",
			"properties": {
				"execution_id": {
					"description": "NormalizationID is the ID of the normalization.",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Normalizations.Progress": {
			"description": "Progress holds the information of the progress of the transformation as a whole.",
			"properties": {
				"completion_percentage": {
					"description": "CompletionPercentage is the current amount of data processed as a percentage.",
					"format": "float",
					"type": "number"
				}
			},
			"type": "object"
		},
		"Normalizations.v1.Status": {
			"default": "NO_STATUS",
			"description": "Status is an enum of the different states that an async task can be in.",
			"enum": [
				"NO_STATUS",
				"WAITING",
				"INITIALIZING",
				"RUNNING",
				"FAILED",
				"COMPLETED",
				"CANCELING",
				"CANCELED",
				"STALE",
				"PROVISIONING",
				"PROVISIONED",
				"PARTIALLY_COMPLETED"
			],
			"type": "string"
		},
		"Pagination": {
			"description": "Details to configure paginated record responses.",
			"properties": {
				"page": {
					"description": "The requested page of records. Default is 1.",
					"format": "int32",
					"minimum": 1,
					"type": "integer"
				},
				"per_page": {
					"description": "The number of records to return per page. Maximum is 500. Default is 100.",
					"format": "int32",
					"maximum": 500,
					"minimum": 1,
					"type": "integer"
				}
			},
			"type": "object"
		},
		"PaginationResponse": {
			"description": "Details to allow follow-up requests to page through records.",
			"properties": {
				"next_page": {
					"description": "The next page to request to fetch the next batch of records.",
					"format": "int32",
					"type": "integer"
				},
				"results": {
					"description": "The count of records returned in this response.",
					"format": "int32",
					"type": "integer"
				},
				"total_results": {
					"description": "The total number of records available for the given request.",
					"format": "int32",
					"type": "integer"
				}
			},
			"type": "object"
		},
		"Prepare_Configs.AddConfigCategoriesBody": {
			"properties": {
				"categories": {
					"items": {
						"format": "int64",
						"type": "string"
					},
					"title": "Categories is the list of category ids to be added to the config",
					"type": "array"
				}
			},
			"title": "AddConfigCategoriesRequest",
			"type": "object"
		},
		"Prepare_Configs.AddConfigCategoriesResponse": {
			"title": "AddConfigCategoriesResponse",
			"type": "object"
		},
		"Prepare_Configs.AddConfigExportColumnsBody": {
			"properties": {
				"export_columns": {
					"items": {
						"type": "string"
					},
					"title": "ExportColumns is the list of export column names to be added to the config",
					"type": "array"
				}
			},
			"title": "AddConfigExportColumnsRequest",
			"type": "object"
		},
		"Prepare_Configs.AddConfigExportColumnsResponse": {
			"title": "AddConfigExportColumnsResponse",
			"type": "object"
		},
		"Prepare_Configs.AddConfigKeysBody": {
			"properties": {
				"keys": {
					"items": {
						"format": "int64",
						"type": "string"
					},
					"title": "Keys is the list of key ids to be added to the config",
					"type": "array"
				}
			},
			"title": "AddConfigKeysRequest",
			"type": "object"
		},
		"Prepare_Configs.AddConfigKeysResponse": {
			"title": "AddConfigKeysResponse",
			"type": "object"
		},
		"Prepare_Configs.Config": {
			"description": "Config holds all the information regarding a dataset publish config.",
			"properties": {
				"created_date_time": {
					"description": "CreatedDateTime is the time that this Config was created and stored.",
					"format": "date-time",
					"type": "string"
				},
				"dataset_publish_config": {
					"allOf": [
						{
							"$ref": "#/definitions/Prepare_Configs.DatasetPublishConfig"
						}
					],
					"description": "DatasetPublishConfig is the dataset publish configuration defined by the user."
				},
				"description": {
					"description": "Description is the description given to the config to help identify what exactly is being\nstored within the config.",
					"type": "string"
				},
				"id": {
					"description": "ID is the ID of the config.",
					"type": "string"
				},
				"name": {
					"description": "Name is the name given to the config.",
					"type": "string"
				},
				"updated_date_time": {
					"description": "UpdatedDateTime is the last time that this Config was updated and stored.",
					"format": "date-time",
					"type": "string"
				},
				"user_id": {
					"description": "UserId is the ID of the user that created the config.",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Prepare_Configs.CreateConfigRequest": {
			"properties": {
				"config": {
					"allOf": [
						{
							"$ref": "#/definitions/Prepare_Configs.DatasetPublishConfig"
						}
					],
					"title": "Config is the dataset prepare config - can be updated after creation"
				},
				"description": {
					"title": "Description is the user assigned description for the config",
					"type": "string"
				},
				"name": {
					"title": "Name is the user assigned name of the config",
					"type": "string"
				}
			},
			"title": "CreateConfigRequest creates a new config",
			"type": "object"
		},
		"Prepare_Configs.CreateConfigResponse": {
			"properties": {
				"id": {
					"title": "ID is the globally unique ID for the config",
					"type": "string"
				}
			},
			"title": "CreateConfigResponse is the response object for rpc CreateConfigRequest",
			"type": "object"
		},
		"Prepare_Configs.DatasetPublishConfig": {
			"description": "DatasetPublishConfig configures a prepare task.",
			"properties": {
				"category_selection": {
					"description": "CategorySelection defines a subset of Categories IDs to prepare. If this is not set then all Categories are prepared (up to a predefined limit).",
					"items": {
						"format": "int64",
						"type": "string"
					},
					"type": "array"
				},
				"export_column_selection": {
					"description": "ExportColumnSelection defines a subset of Export Column names to prepare. If this is not set then all Export Columns are prepared (up to a predefined limit).",
					"items": {
						"type": "string"
					},
					"type": "array"
				},
				"incremental_full_refresh": {
					"description": "IncrementalFullRefresh is a flag indicating that the data from the previous incremental run should not be carried\nforward. It is only valid when supports_incremental flag is set to true.",
					"type": "boolean"
				},
				"key_selection": {
					"description": "KeySelection defines a subset of Key IDs to prepare. If this is not set then all Keys are prepared (up to a predefined limit).",
					"items": {
						"format": "int64",
						"type": "string"
					},
					"type": "array"
				},
				"purge_expired_rows_only": {
					"description": "PurgeExpiredRowsOnly is a flag indicating that this is an expire only incremental run. InsightWriter should not\nexpect any subsequent Write calls with a Body, only a single call with the Header. All necessary stats\nwill be populated in the response to the Write call to the Header. This property is only valid if the\nsupports_incremental flag is set to true. All other properties in the Header will be ignored and will not be\nvalidated.",
					"type": "boolean"
				},
				"redaction_threshold": {
					"description": "RedactionThreshold corresponds to the minimum number of results required\nfor a bin to be included in the results returned.\nDefault value is 100, minimum value is 25.",
					"format": "int64",
					"type": "integer"
				},
				"rounding_threshold": {
					"description": "RoundingThreshold is the number that bin counts will be rounded down by.\nDefault value is 100, minimum value is 25.",
					"format": "int64",
					"type": "integer"
				}
			},
			"type": "object"
		},
		"Prepare_Configs.DeleteConfigCategoriesResponse": {
			"description": "DeleteConfigCategoriesResponse is the empty response for DeleteConfigCategoriesRequest rpc.",
			"type": "object"
		},
		"Prepare_Configs.DeleteConfigExportColumnsResponse": {
			"description": "DeleteConfigExportColumnsResponse is the empty response for DeleteConfigExportColumnsRequest rpc.",
			"type": "object"
		},
		"Prepare_Configs.DeleteConfigKeysResponse": {
			"description": "DeleteConfigKeysResponse is the empty response for DeleteConfigKeysRequest rpc.",
			"type": "object"
		},
		"Prepare_Configs.DeleteConfigResponse": {
			"description": "DeleteConfigResponse is the empty response of the DeleteConfig rpc.",
			"type": "object"
		},
		"Prepare_Configs.GetConfigResponse": {
			"description": "GetConfigResponse is the response of the GetConfig rpc.",
			"properties": {
				"config": {
					"allOf": [
						{
							"$ref": "#/definitions/Prepare_Configs.Config"
						}
					],
					"description": "Config is the dataset prepare configuration that was requested."
				}
			},
			"type": "object"
		},
		"Prepare_Configs.ListConfigCategoriesResponse": {
			"description": "ListConfigCategoriesResponse is the response of ListConfigCategoriesRequest rpc.",
			"properties": {
				"categories": {
					"items": {
						"type": "string"
					},
					"title": "Categories are the categories in the dataset prepare config",
					"type": "array"
				},
				"pagination": {
					"allOf": [
						{
							"$ref": "#/definitions/PaginationResponse"
						}
					],
					"description": "Pagination is the pagination instructions for returned dataset prepare config categories."
				}
			},
			"type": "object"
		},
		"Prepare_Configs.ListConfigExportColumnsResponse": {
			"description": "ListConfigExportColumnsResponse is the response of ListConfigExportColumnsRequest rpc.",
			"properties": {
				"export_columns": {
					"items": {
						"type": "string"
					},
					"title": "Export columns are the export columns in the dataset prepare config",
					"type": "array"
				},
				"pagination": {
					"allOf": [
						{
							"$ref": "#/definitions/PaginationResponse"
						}
					],
					"description": "Pagination is the pagination instructions for returned dataset prepare config export columns."
				}
			},
			"type": "object"
		},
		"Prepare_Configs.ListConfigKeysResponse": {
			"description": "ListConfigKeysResponse is the response of ListConfigKeysRequest rpc.",
			"properties": {
				"keys": {
					"items": {
						"type": "string"
					},
					"title": "Keys are the keys in the dataset prepare config",
					"type": "array"
				},
				"pagination": {
					"allOf": [
						{
							"$ref": "#/definitions/PaginationResponse"
						}
					],
					"description": "Pagination is the pagination instructions for returned dataset prepare config keys."
				}
			},
			"type": "object"
		},
		"Prepare_Configs.ListConfigsResponse": {
			"description": "ListConfigsResponse is the response of the ListConfigs rpc.",
			"properties": {
				"configs": {
					"description": "Configs is a list of dataset prepare configurations.",
					"items": {
						"$ref": "#/definitions/Prepare_Configs.ListedConfigDetails",
						"type": "object"
					},
					"type": "array"
				},
				"pagination": {
					"allOf": [
						{
							"$ref": "#/definitions/PaginationResponse"
						}
					],
					"description": "Pagination is the pagination details of the returned dataset prepare configs."
				}
			},
			"type": "object"
		},
		"Prepare_Configs.ListedConfigDetails": {
			"description": "ListedConfigDetails is a reduced version of Config for list endpoints.",
			"properties": {
				"created_date_time": {
					"description": "CreatedDateTime is the time that this Config was created and stored.",
					"format": "date-time",
					"type": "string"
				},
				"dataset_publish_config_summary": {
					"allOf": [
						{
							"$ref": "#/definitions/Prepare_Configs.PublishConfigSummary"
						}
					],
					"description": "PrepareConfigSummary is the dataset prepare configuration defined by the user."
				},
				"description": {
					"description": "Description is the description given to the config to help identify what exactly is being\nstored within the config.",
					"type": "string"
				},
				"id": {
					"description": "ID is the ID of the config.",
					"type": "string"
				},
				"name": {
					"description": "Name is the name given to the config.",
					"type": "string"
				},
				"updated_date_time": {
					"description": "UpdatedDateTime is the last time that this Config was updated and stored.",
					"format": "date-time",
					"type": "string"
				},
				"user_id": {
					"description": "UserId is the ID of the user that created the config.",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Prepare_Configs.PublishConfigSummary": {
			"description": "PublishConfigSummary is a Config without the full column selection due to message size limits.",
			"properties": {
				"category_column_count": {
					"description": "CategoryColumnCount is the number of category columns in the config.",
					"format": "int64",
					"type": "integer"
				},
				"export_column_count": {
					"description": "ExportColumnCount is the number of export columns in the config.",
					"format": "int64",
					"type": "integer"
				},
				"incremental_full_refresh": {
					"description": "IncrementalFullRefresh is a flag indicating that the data from the previous incremental run should not be carried\nforward. It is only valid when supports_incremental flag is set to true.",
					"type": "boolean"
				},
				"key_column_count": {
					"description": "KeyColumnCount is the number of key columns in the config.",
					"format": "int64",
					"type": "integer"
				},
				"purge_expired_rows_only": {
					"description": "PurgeExpiredRowsOnly is a flag indicating that this is an expire only incremental run. InsightWriter should not\nexpect any subsequent Write calls with a Body, only a single call with the Header. All necessary stats\nwill be populated in the response to the Write call to the Header. This property is only valid if the\nsupports_incremental flag is set to true. All other properties in the Header will be ignored and will not be\nvalidated.",
					"type": "boolean"
				},
				"redaction_threshold": {
					"description": "RedactionThreshold corresponds to the minimum number of results required\nfor a bin to be included in the results returned.",
					"format": "int64",
					"type": "integer"
				},
				"rounding_threshold": {
					"description": "RoundingThreshold is the number that bin counts will be rounded down by.",
					"format": "int64",
					"type": "integer"
				}
			},
			"type": "object"
		},
		"Prepare_Configs.UpdateConfigBody": {
			"description": "UpdateConfigRequest is used to update name and description.",
			"properties": {
				"config": {
					"allOf": [
						{
							"$ref": "#/definitions/Prepare_Configs.DatasetPublishConfig"
						}
					],
					"title": "Config is the dataset prepare config - can be updated after creation"
				},
				"description": {
					"description": "Description is a description of the dataset prepare config.",
					"type": "string"
				},
				"name": {
					"description": "Name is the name assigned to the dataset prepare config.",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Prepare_Configs.UpdateConfigResponse": {
			"description": "UpdateConfigResponse is the empty response of the UpdateConfig rpc.",
			"type": "object"
		},
		"Publishing.CancelPrepareResponse": {
			"description": "CancelPrepareResponse is the empty response for the CancelPrepare rpc.",
			"type": "object"
		},
		"Publishing.DatasetPublishConfig": {
			"description": "DatasetPublishConfig configures a prepare task.",
			"properties": {
				"category_selection": {
					"description": "CategorySelection defines a subset of Categories IDs to prepare. If this is not set then all Categories are prepared (up to a predefined limit).",
					"items": {
						"format": "int64",
						"type": "string"
					},
					"type": "array"
				},
				"export_column_selection": {
					"description": "ExportColumnSelection defines a subset of Export Column names to prepare. If this is not set then all Export Columns are prepared (up to a predefined limit).",
					"items": {
						"type": "string"
					},
					"type": "array"
				},
				"incremental_full_refresh": {
					"description": "IncrementalFullRefresh is a flag indicating that the data from the previous incremental run should not be carried\nforward. It is only valid when supports_incremental flag is set to true.",
					"type": "boolean"
				},
				"key_selection": {
					"description": "KeySelection defines a subset of Key IDs to prepare. If this is not set then all Keys are prepared (up to a predefined limit).",
					"items": {
						"format": "int64",
						"type": "string"
					},
					"type": "array"
				},
				"purge_expired_rows_only": {
					"description": "PurgeExpiredRowsOnly is a flag indicating that this is an expire only incremental run. InsightWriter should not\nexpect any subsequent Write calls with a Body, only a single call with the Header. All necessary stats\nwill be populated in the response to the Write call to the Header. This property is only valid if the\nsupports_incremental flag is set to true. All other properties in the Header will be ignored and will not be\nvalidated.",
					"type": "boolean"
				},
				"redaction_threshold": {
					"description": "RedactionThreshold corresponds to the minimum number of results required\nfor a bin to be included in the results returned.\nDefault value is 100, minimum value is 25.",
					"format": "int64",
					"type": "integer"
				},
				"rounding_threshold": {
					"description": "RoundingThreshold is the number that bin counts will be rounded down by.\nDefault value is 100, minimum value is 25.",
					"format": "int64",
					"type": "integer"
				}
			},
			"type": "object"
		},
		"Publishing.GetPrepareResponse": {
			"description": "GetPrepareResponse is the response for the GetPrepare rpc.",
			"properties": {
				"prepare_details": {
					"allOf": [
						{
							"$ref": "#/definitions/Publishing.PrepareDetails"
						}
					],
					"description": "Prepare holds all information on the prepare as well as the shards being used to process the\nprepare."
				}
			},
			"type": "object"
		},
		"Publishing.GetPrepareStatsResponse": {
			"description": "GetPrepareStatsResponse is the response for the GetPrepareStats rpc.\n\nPrepare",
			"type": "object"
		},
		"Publishing.History": {
			"description": "History holds information about the status of a prepare publish execution\nshard.",
			"properties": {
				"date_time": {
					"description": "DateTime is the created time of the shard.",
					"format": "date-time",
					"type": "string"
				},
				"error": {
					"allOf": [
						{
							"$ref": "#/definitions/Error"
						}
					],
					"description": "Error is the error encountered by the execution shard."
				},
				"message": {
					"description": "Message is the reported message relating to this status change.",
					"type": "string"
				},
				"prepare_status": {
					"allOf": [
						{
							"$ref": "#/definitions/Publishing.PrepareStatus"
						}
					],
					"description": "PrepareStatus is the state of a prepare that has been published."
				},
				"status": {
					"allOf": [
						{
							"$ref": "#/definitions/Publishing.v1.Status"
						}
					],
					"description": "Status is the status of the prepare publish execution shard."
				}
			},
			"type": "object"
		},
		"Publishing.ListPreparesResponse": {
			"description": "ListPreparesResponse is the response of the ListPrepares rpc.",
			"properties": {
				"pagination": {
					"allOf": [
						{
							"$ref": "#/definitions/PaginationResponse"
						}
					],
					"description": "Pagination is the pagination details of the returned prepares."
				},
				"prepares": {
					"description": "Prepares is a list of the prepare records for a particular list request.",
					"items": {
						"$ref": "#/definitions/Publishing.ListedPrepareExecution",
						"type": "object"
					},
					"type": "array"
				}
			},
			"type": "object"
		},
		"Publishing.ListedPrepareExecution": {
			"description": "ListedPrepareExecution holds summary information about a prepare execution.",
			"properties": {
				"cloud_vault_id": {
					"description": "CloudVaultId is the ID of cloud vault where source files are found.",
					"type": "string"
				},
				"config_summary": {
					"allOf": [
						{
							"$ref": "#/definitions/Publishing.PublishConfigSummary"
						}
					],
					"description": "ConfigSummary of the prepare."
				},
				"created_date_time": {
					"description": "CreatedDateTime is the creation date and time of the prepare.",
					"format": "date-time",
					"type": "string"
				},
				"current_status": {
					"allOf": [
						{
							"$ref": "#/definitions/Publishing.v1.Status"
						}
					],
					"description": "CurrentStatus is the latest status of the prepare aggregated from its\nconstituent shards statuses."
				},
				"dataset_id": {
					"description": "DatasetId is the ID of the Dataset that will be prepared.",
					"type": "string"
				},
				"expiration_date_time": {
					"description": "ExpirationDateTime is the expiry date time of the prepare compute.",
					"format": "date-time",
					"type": "string"
				},
				"id": {
					"description": "Id is the ID of the prepare.",
					"type": "string"
				},
				"prepare_status": {
					"allOf": [
						{
							"$ref": "#/definitions/Publishing.PrepareStatus"
						}
					],
					"description": "PrepareStatus is the state of a prepare that has been published."
				},
				"progress": {
					"allOf": [
						{
							"$ref": "#/definitions/Publishing.Progress"
						}
					],
					"description": "Progress is the progress of the prepare operation."
				},
				"recordset_id": {
					"description": "RecordsetId is the recordset that was used in the prepare.",
					"type": "string"
				},
				"updated_date_time": {
					"description": "UpdatedDateTime is the latest date and time any prepare shards were\nupdated.",
					"format": "date-time",
					"type": "string"
				},
				"user_id": {
					"description": "UserId is the ID of the user who created the prepare.",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Publishing.PrepareDetails": {
			"description": "PrepareDetails returns info about a prepare execution as well as its execution history.",
			"properties": {
				"history": {
					"items": {
						"$ref": "#/definitions/Publishing.History",
						"type": "object"
					},
					"type": "array"
				},
				"prepare": {
					"$ref": "#/definitions/Publishing.PrepareExecution"
				}
			},
			"type": "object"
		},
		"Publishing.PrepareExecution": {
			"description": "PrepareExecution holds global information about a prepare publish operation.",
			"properties": {
				"cloud_vault_id": {
					"description": "CloudVaultId is the ID of cloud vault where source files are found.",
					"type": "string"
				},
				"config": {
					"allOf": [
						{
							"$ref": "#/definitions/Publishing.DatasetPublishConfig"
						}
					],
					"title": "Config of the publish"
				},
				"config_embedded": {
					"allOf": [
						{
							"$ref": "#/definitions/Publishing.DatasetPublishConfig"
						}
					],
					"description": "ConfigEmbedded is the config that was supplied, if an embedded config was used to create the prepare."
				},
				"config_id": {
					"description": "ConfigID is the ID of the config that was supplied, if a saved config was used to create the prepare.",
					"type": "string"
				},
				"created_date_time": {
					"description": "CreatedDateTime is the creation date and time of the prepare publish.",
					"format": "date-time",
					"type": "string"
				},
				"current_status": {
					"allOf": [
						{
							"$ref": "#/definitions/Publishing.v1.Status"
						}
					],
					"description": "CurrentStatus is the latest status of the prepare publish aggregated from its\nconstituent shards statuses."
				},
				"dataset_id": {
					"description": "DatasetId is the ID of the Dataset that the data will be published to.",
					"type": "string"
				},
				"expiration_date_time": {
					"description": "ExpirationDateTime is the expiry date time of the prepare compute.",
					"format": "date-time",
					"type": "string"
				},
				"id": {
					"description": "Id is the ID of the prepare publish.",
					"type": "string"
				},
				"prepare_status": {
					"allOf": [
						{
							"$ref": "#/definitions/Publishing.PrepareStatus"
						}
					],
					"description": "PrepareStatus is the state of a prepare that has been published."
				},
				"progress": {
					"allOf": [
						{
							"$ref": "#/definitions/Publishing.Progress"
						}
					],
					"description": "Progress is the progress of the prepare operation."
				},
				"recordset_id": {
					"description": "RecordsetId is the recordset that was used in the prepare.",
					"type": "string"
				},
				"updated_date_time": {
					"description": "UpdatedDateTime is the latest date and time any prepare publish shards were\nupdated.",
					"format": "date-time",
					"type": "string"
				},
				"user_id": {
					"description": "UserId is the ID of the user who created the prepare publish.",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Publishing.PrepareRequest": {
			"description": "PrepareRequest is used to prepare a dataset.",
			"properties": {
				"cloud_vault_id": {
					"description": "CloudVaultId is the ID of cloud vault where source files are found.",
					"type": "string"
				},
				"config_embedded": {
					"$ref": "#/definitions/Publishing.DatasetPublishConfig"
				},
				"config_id": {
					"type": "string"
				},
				"dataset_id": {
					"description": "DatasetId is the ID of the Dataset to prepare.",
					"type": "string"
				},
				"recordset_id": {
					"description": "RecordsetId determines the set of files to normalise. All files in the cloud vault with the specific prefix will be considered.",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Publishing.PrepareResponse": {
			"description": "PrepareResponse is the empty response for Prepare rpc.",
			"properties": {
				"execution_id": {
					"type": "string"
				}
			},
			"type": "object"
		},
		"Publishing.PrepareStatus": {
			"default": "NO_STATUS",
			"description": "PrepareStatus holds info about a prepare once published.",
			"enum": [
				"NO_STATUS",
				"PUBLISHED",
				"EXPIRED",
				"DELETED",
				"PUBLISHING"
			],
			"type": "string"
		},
		"Publishing.Progress": {
			"description": "Progress holds the information of the progress of the prepare execution as a whole.",
			"properties": {
				"completion_percentage": {
					"description": "CompletionPercentage is the current amount of data processed as a percentage.",
					"format": "float",
					"type": "number"
				}
			},
			"type": "object"
		},
		"Publishing.PublishConfigSummary": {
			"description": "PublishConfigSummary is a Config without the full column selection due to message size limits.",
			"properties": {
				"category_column_count": {
					"description": "CategoryColumnCount is the number of category columns in the config.",
					"format": "int64",
					"type": "integer"
				},
				"export_column_count": {
					"description": "ExportColumnCount is the number of export columns in the config.",
					"format": "int64",
					"type": "integer"
				},
				"incremental_full_refresh": {
					"description": "IncrementalFullRefresh is a flag indicating that the data from the previous incremental run should not be carried\nforward. It is only valid when supports_incremental flag is set to true.",
					"type": "boolean"
				},
				"key_column_count": {
					"description": "KeyColumnCount is the number of key columns in the config.",
					"format": "int64",
					"type": "integer"
				},
				"purge_expired_rows_only": {
					"description": "PurgeExpiredRowsOnly is a flag indicating that this is an expire only incremental run. InsightWriter should not\nexpect any subsequent Write calls with a Body, only a single call with the Header. All necessary stats\nwill be populated in the response to the Write call to the Header. This property is only valid if the\nsupports_incremental flag is set to true. All other properties in the Header will be ignored and will not be\nvalidated.",
					"type": "boolean"
				},
				"redaction_threshold": {
					"description": "RedactionThreshold corresponds to the minimum number of results required\nfor a bin to be included in the results returned.",
					"format": "int64",
					"type": "integer"
				},
				"rounding_threshold": {
					"description": "RoundingThreshold is the number that bin counts will be rounded down by.",
					"format": "int64",
					"type": "integer"
				}
			},
			"type": "object"
		},
		"Publishing.PublishResponse": {
			"description": "PublishResponse is the empty response for the Publish rpc.",
			"properties": {
				"execution_id": {
					"description": "ExecutionID is the id of the prepare execution to publish to the dataset.",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Publishing.v1.Status": {
			"default": "NO_STATUS",
			"description": "Status is an enum of the different states that an async task can be in.",
			"enum": [
				"NO_STATUS",
				"WAITING",
				"INITIALIZING",
				"RUNNING",
				"FAILED",
				"COMPLETED",
				"CANCELING",
				"CANCELED",
				"STALE",
				"PROVISIONING",
				"PROVISIONED",
				"PARTIALLY_COMPLETED"
			],
			"type": "string"
		},
		"Queries.CreatePairQueryRequest": {
			"description": "CreatePairQueryRequest is the input to the CreatePairQuery method.",
			"properties": {
				"collaborator_dataset_id": {
					"description": "CollaboratorDatasetId is the ID of the dataset you are collaborating with.",
					"type": "string"
				},
				"column_identifier": {
					"allOf": [
						{
							"$ref": "#/definitions/Queries.PairColumnIdentifier"
						}
					],
					"description": "ColumnIdentifier contains details of the column to be used as the identifier."
				},
				"dataset_id": {
					"description": "DatasetId is the ID of the dataset you want the query to be run against.",
					"type": "string"
				},
				"query_name": {
					"description": "QueryName is the name of the query.",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Queries.CreatePairQueryResponse": {
			"description": "CreatePairQueryResponse is the output of the CreatePairQuery method.",
			"properties": {
				"query_id": {
					"description": "QueryId is the ID of the PAIR activation query.",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Queries.CreatePrivatePathRequest": {
			"description": "CreatePrivatePathRequest is the input to the CreatePrivatePath method.",
			"properties": {
				"dataset_ids": {
					"description": "DatasetIds is the list of datasets allowed in the collaboration.",
					"items": {
						"type": "string"
					},
					"type": "array"
				}
			},
			"type": "object"
		},
		"Queries.CreatePrivatePathResponse": {
			"description": "CreatePrivatePathResponse is the output of the CreatePrivatePath method.",
			"properties": {
				"collaboration_id": {
					"description": "CollaborationId is the unique ID generated for the private path collaboration.\nThis value must be kept safe by the user as it's not stored by InfoSum and cannot be retrieved.",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Queries.GetPrivatePathResponse": {
			"description": "GetPrivatePathResponse is the output of GetPrivatePath method.",
			"properties": {
				"private_path_datasets": {
					"description": "PrivatePathDatasets is list of datasets used in the private path collaboration.",
					"items": {
						"$ref": "#/definitions/Queries.PrivatePathDataset",
						"type": "object"
					},
					"type": "array"
				}
			},
			"type": "object"
		},
		"Queries.PairColumnIdentifier": {
			"description": "PairColumnIdentifier defines what column and data type should be used as the identifier in a PAIR query.",
			"properties": {
				"column_name": {
					"description": "ColumnName is the name of the column to be used as the identifier.",
					"type": "string"
				},
				"column_type": {
					"allOf": [
						{
							"$ref": "#/definitions/Queries.PairColumnType"
						}
					],
					"description": "ColumnType is the data type of the column."
				}
			},
			"type": "object"
		},
		"Queries.PairColumnType": {
			"default": "PAIR_COLUMN_TYPE_INVALID",
			"description": "PairColumnType is a list of support identifier for the Google PAIR protocol.",
			"enum": [
				"PAIR_COLUMN_TYPE_INVALID",
				"PAIR_COLUMN_TYPE_EMAIL"
			],
			"type": "string"
		},
		"Queries.PrivatePathDataset": {
			"description": "PrivatePathDataset is details of a dataset used in a private path collaboration.",
			"properties": {
				"dataset_id": {
					"description": "DatasetId is the ID of the dataset.",
					"type": "string"
				},
				"use_time": {
					"description": "UseTime will be filled with the date and time of activation.",
					"format": "date-time",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Recordset_Configs.Config": {
			"description": "Config contains information about a recordset config.",
			"properties": {
				"created_by": {
					"description": "Output only. CreatedBy is the id of the user who created the config.",
					"readOnly": true,
					"type": "string"
				},
				"created_date_time": {
					"description": "Output only. CreatedDateTime is the date time of when the config was created.",
					"format": "date-time",
					"readOnly": true,
					"type": "string"
				},
				"description": {
					"description": "Description is an optional description given to this config.",
					"type": "string"
				},
				"file_type": {
					"allOf": [
						{
							"$ref": "#/definitions/Recordset_Configs.FileType"
						}
					],
					"description": "Allows the user to dictate the file format used by the recordset creation task to read the input files, disregarding any file extensions."
				},
				"header_names": {
					"description": "HeaderNames is a list of the header/column names. To be provided if the files do not contain a header row.\nMust be in the same order as the columns in the files.",
					"items": {
						"type": "string"
					},
					"type": "array"
				},
				"header_row": {
					"description": "HeaderRow indicates whether the files have a header row.",
					"type": "boolean"
				},
				"id": {
					"description": "Output only. id is the config ID.",
					"readOnly": true,
					"type": "string"
				},
				"name": {
					"description": "Name is a unique name to help identify the config. Valid characters are alphanumeric, '_', '-', ' '.",
					"type": "string"
				},
				"primary_delimiter": {
					"description": "PrimaryDelimiter is the primary delimiter of the data.",
					"type": "string"
				},
				"secondary_delimiter": {
					"description": "SecondaryDelimiter is the secondary delimiter of the data, if any.",
					"type": "string"
				},
				"updated_date_time": {
					"description": "Output only. UpdatedDateTime is date time of when the config was last updated.",
					"format": "date-time",
					"readOnly": true,
					"type": "string"
				}
			},
			"type": "object"
		},
		"Recordset_Configs.CreateConfigRequest": {
			"description": "CreateConfigRequest contains the information required to create a recordset config.",
			"properties": {
				"description": {
					"description": "An optional description given to the config.",
					"type": "string"
				},
				"file_type": {
					"allOf": [
						{
							"$ref": "#/definitions/Recordset_Configs.FileType"
						}
					],
					"description": "Allows the user to dictate the file format used by the recordset creation task to read the input files, disregarding any file extensions."
				},
				"header_names": {
					"description": "The names of the headers/columns. Must be provided if the input files do not have a header row, and in the same order as the columns in the input files.",
					"items": {
						"type": "string"
					},
					"type": "array"
				},
				"header_row": {
					"description": "Indicates whether or not the input files have a header row.",
					"type": "boolean"
				},
				"name": {
					"description": "The unique name to identify the config.",
					"type": "string"
				},
				"primary_delimiter": {
					"description": "The primary delimiter used in the input files.",
					"type": "string"
				},
				"secondary_delimiter": {
					"description": "The secondary delimiter (if any) used in the input files.",
					"type": "string"
				}
			},
			"required": [
				"name",
				"primary_delimiter",
				"header_row"
			],
			"type": "object"
		},
		"Recordset_Configs.CreateConfigResponse": {
			"description": "CreateConfigResponse contains the ID of the Config.",
			"properties": {
				"config_id": {
					"description": "The ID of the config created.",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Recordset_Configs.DeleteConfigResponse": {
			"description": "DeleteConfigResponse is the output from the DeleteConfig method.",
			"type": "object"
		},
		"Recordset_Configs.FileType": {
			"default": "AUTO",
			"description": "- AUTO: Auto, default, detects the file type based on file extension.\n - CSV: CSV specifies that all files for this recordset creation are CSV, regardless of file extension.\n - PARQUET: Parquet specifies that all files for this recordset creation are Parquet, regardless of file extension.",
			"enum": [
				"AUTO",
				"CSV",
				"PARQUET"
			],
			"title": "FileType enumerates the file type detection behaviour when creating a recordset",
			"type": "string"
		},
		"Recordset_Configs.GetConfigResponse": {
			"description": "GetConfigResponse contains the requested config.",
			"properties": {
				"config": {
					"allOf": [
						{
							"$ref": "#/definitions/Recordset_Configs.Config"
						}
					],
					"description": "The details of the requested config."
				}
			},
			"type": "object"
		},
		"Recordset_Configs.ListConfigsResponse": {
			"description": "ListConfigsResponse returns the matching configs.",
			"properties": {
				"configs": {
					"description": "The list of configs that match the critera of the request.",
					"items": {
						"$ref": "#/definitions/Recordset_Configs.Config",
						"type": "object"
					},
					"type": "array"
				},
				"pagination": {
					"allOf": [
						{
							"$ref": "#/definitions/PaginationResponse"
						}
					],
					"description": "Details of the pagination of this response."
				}
			},
			"type": "object"
		},
		"Recordset_Configs.UpdateConfigResponse": {
			"description": "UpdateConfigResponse is the output from the UpdateConfig method.",
			"properties": {
				"config": {
					"$ref": "#/definitions/Recordset_Configs.Config"
				}
			},
			"type": "object"
		},
		"Recordset_Creation.CancelExecutionResponse": {
			"description": "CancelExecutionResponse is the output from the CancelExecution method.",
			"type": "object"
		},
		"Recordset_Creation.CreateExecutionRequest": {
			"description": "CreateExecutionRequest contains the information required to create a recordset.",
			"properties": {
				"cloud_vault_id": {
					"description": "The globally unique identifier for the Cloud Vault.",
					"type": "string"
				},
				"config_id": {
					"description": "The ID of a recordset config that can be used to execute the creation of a recordset.",
					"type": "string"
				},
				"execution_config": {
					"allOf": [
						{
							"$ref": "#/definitions/Recordset_Creation.ExecutionConfig"
						}
					],
					"description": "The required information needed to execute the creation of a recordset."
				},
				"filepaths": {
					"description": "A list of input files including the full path from the root of the CloudVault to be used to create the recordset. All files must be in the same format. Must not be set if `folder` has been specified.",
					"items": {
						"type": "string"
					},
					"type": "array"
				},
				"recordset_name": {
					"description": "The name given to the recordset that will be created.",
					"type": "string"
				}
			},
			"required": [
				"cloud_vault_id",
				"recordset_name"
			],
			"type": "object"
		},
		"Recordset_Creation.CreateExecutionResponse": {
			"description": "CreateExecutionResponse contains the ID of the execution.",
			"properties": {
				"execution_id": {
					"description": "The ID of the execution created.",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Recordset_Creation.Execution": {
			"description": "Execution contains information about the creation of a\n recordset.",
			"properties": {
				"cloud_vault_id": {
					"description": "CloudVaultId is the ID of the cloud vault storing the recordset.",
					"type": "string"
				},
				"created_date_time": {
					"description": "CreatedDateTime is the creation date and time of the current execution.",
					"format": "date-time",
					"type": "string"
				},
				"current_status": {
					"allOf": [
						{
							"$ref": "#/definitions/Recordset_Creation.v1.Status"
						}
					],
					"description": "CurrentStatus is the status of the current execution."
				},
				"id": {
					"description": "Id is the ID of the execution.",
					"type": "string"
				},
				"progress": {
					"allOf": [
						{
							"$ref": "#/definitions/Recordset_Creation.Progress"
						}
					],
					"description": "Progress has the information of the progress of the recordset."
				},
				"recordset_id": {
					"description": "RecordsetId is the ID of the created recordset.",
					"type": "string"
				},
				"recordset_name": {
					"title": "RecordsetName is the name givane to the recordset",
					"type": "string"
				},
				"updated_date_time": {
					"description": "UpdatedDateTime is the date and time the execution was updated.",
					"format": "date-time",
					"type": "string"
				},
				"user_id": {
					"description": "UserId is the ID of the user who executed the recordset creation.",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Recordset_Creation.ExecutionConfig": {
			"description": "ExecutionConfig contains the needed information to create an recordset execution.",
			"properties": {
				"file_type": {
					"allOf": [
						{
							"$ref": "#/definitions/Recordset_Creation.FileType"
						}
					],
					"description": "Allows the user to dictate the file format used by the recordset creation task to read the input files, disregarding any file extensions."
				},
				"header_names": {
					"description": "HeaderNames is a list of the header/column names. To be provided if the files do not contain a header row.\nMust be in the same order as the columns in the files.",
					"items": {
						"type": "string"
					},
					"type": "array"
				},
				"header_row": {
					"description": "HeaderRow indicates whether the input files contain a header row.",
					"type": "boolean"
				},
				"primary_delimiter": {
					"description": "PrimaryDelimiter is the primary delimiter of the input files.",
					"type": "string"
				},
				"secondary_delimiter": {
					"description": "SecondaryDelimiter is the secondary delimiter (if any) of the input files.",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Recordset_Creation.ExecutionDetails": {
			"description": "ExecutionDetails holds detailed information about an execution and its history.",
			"properties": {
				"cloud_vault_id": {
					"description": "CloudVaultID is the ID of the cloud vault storing the recordset.",
					"type": "string"
				},
				"config_id": {
					"description": "Config_id is the ID of the config used to create the recordset execution.",
					"type": "string"
				},
				"created_date_time": {
					"description": "CreatedDateTime is the creation date and time of the current execution.",
					"format": "date-time",
					"type": "string"
				},
				"current_status": {
					"allOf": [
						{
							"$ref": "#/definitions/Recordset_Creation.v1.Status"
						}
					],
					"description": "CurrentStatus is the status of the current execution."
				},
				"execution_config": {
					"allOf": [
						{
							"$ref": "#/definitions/Recordset_Creation.ExecutionConfig"
						}
					],
					"description": "ExecutionConfig contains supplied config used to execute the request."
				},
				"filepaths": {
					"description": "Filepaths is a list of the paths to the input files from the root of the cloudvault.",
					"items": {
						"type": "string"
					},
					"type": "array"
				},
				"history": {
					"description": "History is the status history of the execution execution.",
					"items": {
						"$ref": "#/definitions/Recordset_Creation.History",
						"type": "object"
					},
					"type": "array"
				},
				"id": {
					"description": "Id is the ID of the execution.",
					"type": "string"
				},
				"progress": {
					"allOf": [
						{
							"$ref": "#/definitions/Recordset_Creation.ExecutionProgress"
						}
					],
					"description": "Progress has the information of the progress of the recordset."
				},
				"recordset_id": {
					"description": "RecordsetId is the ID of the created recordset.",
					"type": "string"
				},
				"recordset_name": {
					"description": "RecordsetName is the name that will be given to the recordset. Valid characters are alphanumeric, '_', '-', ' '.",
					"type": "string"
				},
				"updated_date_time": {
					"description": "UpdatedDateTime is the date and time the execution was updated.",
					"format": "date-time",
					"type": "string"
				},
				"user_id": {
					"description": "UserId is the ID of the user who executed the recordset creation.",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Recordset_Creation.ExecutionProgress": {
			"description": "ExecutionProgress holds progress information of the import execution as a whole.",
			"properties": {
				"completion_percentage": {
					"description": "CompletionPercentage indicates the completion of the process.",
					"format": "float",
					"type": "number"
				},
				"lines_processed": {
					"description": "LinesProcessed is the number of lines of the input files that have been processed.",
					"format": "int64",
					"type": "string"
				},
				"malformed_lines": {
					"description": "MalformedLines is the total number of lines that are malformed.",
					"format": "int64",
					"type": "string"
				},
				"total_lines": {
					"description": "TotalLines is the total number of lines in the input files.",
					"format": "int64",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Recordset_Creation.FileType": {
			"default": "AUTO",
			"description": "- AUTO: Auto, default, detects the file type based on file extension.\n - CSV: CSV specifies that all files for this recordset creation are CSV, regardless of file extension.\n - PARQUET: Parquet specifies that all files for this recordset creation are Parquet, regardless of file extension.",
			"enum": [
				"AUTO",
				"CSV",
				"PARQUET"
			],
			"title": "FileType enumerates the file type detection behaviour when creating a recordset",
			"type": "string"
		},
		"Recordset_Creation.GetExecutionResponse": {
			"description": "GetExecutionResponse contains the requested execution.",
			"properties": {
				"execution_details": {
					"allOf": [
						{
							"$ref": "#/definitions/Recordset_Creation.ExecutionDetails"
						}
					],
					"description": "The details of the requested execution."
				}
			},
			"type": "object"
		},
		"Recordset_Creation.History": {
			"description": "History holds information about the status of the recordset creation execution.",
			"properties": {
				"date_time": {
					"format": "date-time",
					"type": "string"
				},
				"error": {
					"$ref": "#/definitions/Error"
				},
				"message": {
					"type": "string"
				},
				"status": {
					"$ref": "#/definitions/Recordset_Creation.v1.Status"
				}
			},
			"type": "object"
		},
		"Recordset_Creation.ListExecutionsResponse": {
			"description": "ListExecutionsResponse returns the matching executions.",
			"properties": {
				"executions": {
					"description": "The list of executions that match the criteria of the request.",
					"items": {
						"$ref": "#/definitions/Recordset_Creation.Execution",
						"type": "object"
					},
					"type": "array"
				},
				"pagination": {
					"allOf": [
						{
							"$ref": "#/definitions/PaginationResponse"
						}
					],
					"description": "Details of the pagination of this response."
				}
			},
			"type": "object"
		},
		"Recordset_Creation.Progress": {
			"description": "Progress holds the information of the progress of the import execution as a whole.",
			"properties": {
				"completion_percentage": {
					"description": "CompletionPercentage indicates the completion of the process.",
					"format": "float",
					"type": "number"
				},
				"lines_processed": {
					"description": "LinesProcessed is the number of lines of the input files that have been processed.",
					"format": "int64",
					"type": "string"
				},
				"malformed_lines": {
					"description": "MalformedLines is the total number of lines that are malformed.",
					"format": "int64",
					"type": "string"
				},
				"total_lines": {
					"description": "TotalLines is the total number of lines in the input files.",
					"format": "int64",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Recordset_Creation.v1.Status": {
			"default": "NO_STATUS",
			"description": "Status is an enum of the different states that an async task can be in.",
			"enum": [
				"NO_STATUS",
				"WAITING",
				"INITIALIZING",
				"RUNNING",
				"FAILED",
				"COMPLETED",
				"CANCELING",
				"CANCELED",
				"STALE",
				"PROVISIONING",
				"PROVISIONED",
				"PARTIALLY_COMPLETED"
			],
			"type": "string"
		},
		"Recordsets.AttributeColumn": {
			"description": "AttributeColumn contains metadata about an Insight Column.",
			"properties": {
				"category_id": {
					"description": "CategoryId is the category ID in the global schema for the column.",
					"format": "int64",
					"type": "string"
				},
				"category_name": {
					"description": "CategoryName is the category name in the global schema for the column.",
					"type": "string"
				},
				"data_type": {
					"allOf": [
						{
							"$ref": "#/definitions/Recordsets.DataType"
						}
					],
					"description": "DataType is how the data should be semantically treated when querying: Continuous or Categorical."
				},
				"is_custom": {
					"description": "IsCustom identifies if this column is a custom attribute (not in the global schema).",
					"type": "boolean"
				},
				"representation_id": {
					"description": "RepresentationId is the representation ID in the global schema for the column.",
					"format": "int64",
					"type": "string"
				},
				"representation_name": {
					"description": "RepresentationName is the category name in the global schema for the column.",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Recordsets.Column": {
			"properties": {
				"attribute_column": {
					"$ref": "#/definitions/Recordsets.AttributeColumn"
				},
				"key_column": {
					"$ref": "#/definitions/Recordsets.KeyColumn"
				},
				"name": {
					"title": "name is the column name\nfor key_columns name is the name in the global schema.\nfor AttributeColumns name must be same as RepresentationName\nfor raw_columns name is the name of the column",
					"type": "string"
				},
				"pii": {
					"title": "pii is set to true if column contains sensitive data",
					"type": "boolean"
				},
				"raw_column": {
					"$ref": "#/definitions/Recordsets.RawColumn"
				},
				"statistics": {
					"allOf": [
						{
							"$ref": "#/definitions/Recordsets.ColumnStats"
						}
					],
					"title": "statistics is the stats for a column"
				},
				"value_type": {
					"allOf": [
						{
							"$ref": "#/definitions/Recordsets.ValueType"
						}
					],
					"title": "value_type is the type of values stored in this column"
				}
			},
			"title": "Column contains details of each column in the recordset.\nFor Raw columns it's sufficient to only define name and value_type",
			"type": "object"
		},
		"Recordsets.ColumnStats": {
			"description": "ColumnStats is the statistics of a column.",
			"properties": {
				"cell_count": {
					"description": "CellCount of non-null cells in the column.",
					"format": "int64",
					"type": "string"
				},
				"invalid_count": {
					"description": "InvalidCount is the count of invalid values inside the cells in the column that could not be processed.",
					"format": "int64",
					"type": "string"
				},
				"null_count": {
					"description": "NullCount is the count of null values inside the cells in the column.",
					"format": "int64",
					"type": "string"
				},
				"value_count": {
					"description": "ValueCount is the count of valid values inside the cells in the column.",
					"format": "int64",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Recordsets.DataType": {
			"default": "DATA_TYPE_INVALID",
			"description": "DataType is how the data should be semantically treated when querying.\n\n - DATA_TYPE_INVALID: DATA_TYPE_UNSPECIFIED\n - CONTINUOUS: CONTINUOUS data can only be represented by integers.\n - CATEGORICAL: CATEGORICAL data can be represented by all data types.",
			"enum": [
				"DATA_TYPE_INVALID",
				"CONTINUOUS",
				"CATEGORICAL"
			],
			"type": "string"
		},
		"Recordsets.DeleteResponse": {
			"description": "DeleteResponse is an empty response for the Delete file request.",
			"type": "object"
		},
		"Recordsets.GetResponse": {
			"description": "GetResponse returns the requested recordset.",
			"properties": {
				"recordset": {
					"allOf": [
						{
							"$ref": "#/definitions/Recordsets.Recordset"
						}
					],
					"description": "The details of the requested recordset."
				}
			},
			"type": "object"
		},
		"Recordsets.Incremental": {
			"description": "Incremental defines primary key and ttl for incremental row.",
			"properties": {
				"primary_key_column_name": {
					"description": "PrimaryKeyColumnName is the column name for unique identifier. It will be used to disambiguate an Update from an Add, when\nthe data represents and incremental update. It is also used when deleting a record.\nIt will only be validated and acted on if the SupportsIncremental property in the Header is set to true.",
					"type": "string"
				},
				"ttl_column_name": {
					"description": "TTL Column Name is the name of the column that contains TTL time in milliseconds\nIt will only be validated and acted on if the SupportsIncremental property in the Header is set to true.",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Recordsets.KeyColumn": {
			"description": "KeyColumn contains metadata about a Key.",
			"properties": {
				"id": {
					"description": "Id in the global schema for the Key or a custom ID.",
					"format": "int64",
					"type": "string"
				},
				"is_custom": {
					"description": "IsCustom identifies if this key is a custom key (not in the global schema).",
					"type": "boolean"
				},
				"name": {
					"description": "Name in the global schema for the Key.",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Recordsets.ListColumnsResponse": {
			"description": "ListColumnsResponse returns the list of Recordset columns.",
			"properties": {
				"columns": {
					"description": "The list of Recordset columns that match the criteria of the request.",
					"items": {
						"$ref": "#/definitions/Recordsets.Column",
						"type": "object"
					},
					"type": "array"
				},
				"pagination": {
					"allOf": [
						{
							"$ref": "#/definitions/PaginationResponse"
						}
					],
					"description": "Details of the pagination of this response."
				}
			},
			"type": "object"
		},
		"Recordsets.ListResponse": {
			"description": "ListResponse returns the matching recordsets.",
			"properties": {
				"pagination": {
					"allOf": [
						{
							"$ref": "#/definitions/PaginationResponse"
						}
					],
					"description": "Details of the pagination of this response."
				},
				"recordsets": {
					"description": "The list of recordset overviews that match the criteria of the request.",
					"items": {
						"$ref": "#/definitions/Recordsets.RecordsetOverview",
						"type": "object"
					},
					"type": "array"
				}
			},
			"type": "object"
		},
		"Recordsets.Lock": {
			"description": "Lock is the represenation of a single lock on a recordset.",
			"properties": {
				"created_date_time": {
					"description": "CreatedDateTime is the date and time that the lock was created.",
					"format": "date-time",
					"type": "string"
				},
				"task_id": {
					"description": "TaskID is the id of the task that has a lock on a recordset.",
					"type": "string"
				},
				"task_type": {
					"description": "TaskType is type of the task that has a lock on a recordset.",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Recordsets.Normalization": {
			"description": "Normalization contains metadata about the normalized recordset.",
			"properties": {
				"global_schema_version": {
					"title": "global_schema_version is the global_schema version used to normalize the data",
					"type": "string"
				},
				"incremental": {
					"$ref": "#/definitions/Recordsets.Incremental"
				}
			},
			"type": "object"
		},
		"Recordsets.Origin": {
			"description": "Origin is the entity that contains information about the origin of a file.",
			"properties": {
				"properties": {
					"additionalProperties": {
						"type": "string"
					},
					"description": "A map of additional properties related to the creation of this file.",
					"readOnly": true,
					"type": "object"
				},
				"task_id": {
					"description": "The unique identifier of the task that caused this file to be created.",
					"readOnly": true,
					"type": "string"
				},
				"task_type": {
					"description": "The type of the task that caused this file to be created.",
					"readOnly": true,
					"type": "string"
				}
			},
			"readOnly": true,
			"type": "object"
		},
		"Recordsets.RawColumn": {
			"title": "RawColumn is used when the column contains raw data.\nexamples:  transformed columns or normalisation export columns",
			"type": "object"
		},
		"Recordsets.Recordset": {
			"description": "Recordset contains an overview of the recordset, without column details.",
			"properties": {
				"attribute_column_count": {
					"description": "AttributeColumnCount is the count of all the Attribute Columns.",
					"format": "int64",
					"type": "string"
				},
				"average_fill_rate": {
					"description": "AverageFillRate is the average fill rate of all columns.",
					"format": "float",
					"type": "number"
				},
				"columns_headers": {
					"description": "ColumnHeaders is a list of the column header values.",
					"items": {
						"type": "string"
					},
					"type": "array"
				},
				"created_date_time": {
					"description": "CreatedDateTime is the date time of when the recordset was created.",
					"format": "date-time",
					"type": "string"
				},
				"file_count": {
					"format": "int64",
					"title": "file_count is the total number of files in the recordset",
					"type": "string"
				},
				"folder_path": {
					"title": "folderPath is the location where recordset is stored",
					"type": "string"
				},
				"id": {
					"title": "id is the recordset ID",
					"type": "string"
				},
				"is_publishable": {
					"description": "IsPublishable is a flag used to mark the recordset as publishable.",
					"type": "boolean"
				},
				"key_column_count": {
					"description": "KeyColumnCount is the count of all the Key Columns.",
					"format": "int64",
					"type": "string"
				},
				"locks": {
					"items": {
						"$ref": "#/definitions/Recordsets.Lock",
						"type": "object"
					},
					"title": "Locks are any locks currently in place for this recordset",
					"type": "array"
				},
				"name": {
					"description": "name is the given name to a recordset\nValid characters are alphanumeric, '_', '-', ' '.",
					"type": "string"
				},
				"normalization_details": {
					"allOf": [
						{
							"$ref": "#/definitions/Recordsets.Normalization"
						}
					],
					"description": "Normalization details contains metadata about the normalized recordset."
				},
				"origin": {
					"allOf": [
						{
							"$ref": "#/definitions/Recordsets.Origin"
						}
					],
					"description": "origin is details of the job that created the recordset."
				},
				"raw_column_count": {
					"description": "RawColumnCount is the count of all the Raw Columns.",
					"format": "int64",
					"type": "string"
				},
				"record_count": {
					"format": "int64",
					"title": "record_count is the total number of rows in the recordset",
					"type": "string"
				},
				"size": {
					"format": "int64",
					"title": "size is the size of the recordset in bytes",
					"type": "string"
				},
				"total_size": {
					"description": "total_size is the size in bytes of the record set.",
					"format": "int64",
					"type": "string"
				},
				"updated_date_time": {
					"description": "UpdatedDateTime is date time of when the recordset was last updated (renamed).",
					"format": "date-time",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Recordsets.RecordsetOverview": {
			"description": "RecordsetOverview contains an overview of the recordset.",
			"properties": {
				"attribute_column_count": {
					"description": "AttributeColumnCount is the count of all the Attribute Columns.",
					"format": "int64",
					"type": "string"
				},
				"average_fill_rate": {
					"description": "AverageFillRate is the average fill rate of all columns.",
					"format": "float",
					"type": "number"
				},
				"created_date_time": {
					"description": "CreatedDateTime is the date time of when the recordset was created.",
					"format": "date-time",
					"type": "string"
				},
				"id": {
					"title": "ID is the recordset ID",
					"type": "string"
				},
				"is_publishable": {
					"description": "IsPublishable is a flag used to mark the recordset as publishable.",
					"type": "boolean"
				},
				"key_column_count": {
					"description": "KeyColumnCount is the count of all the Key Columns.",
					"format": "int64",
					"type": "string"
				},
				"locks": {
					"items": {
						"$ref": "#/definitions/Recordsets.Lock",
						"type": "object"
					},
					"title": "Locks are any locks currently in place for this recordset",
					"type": "array"
				},
				"name": {
					"description": "name is the given name to a recordset\nValid characters are alphanumeric, '_', '-', ' '.",
					"type": "string"
				},
				"origin": {
					"allOf": [
						{
							"$ref": "#/definitions/Recordsets.Origin"
						}
					],
					"description": "Origin is details of the job that created the recordset."
				},
				"raw_column_count": {
					"description": "RawColumnCount is the count of all the Raw Columns.",
					"format": "int64",
					"type": "string"
				},
				"record_count": {
					"format": "int64",
					"title": "RecordCount is the total number of rows in the recordset",
					"type": "string"
				},
				"size": {
					"format": "int64",
					"title": "size is the size of the recordset in bytes",
					"type": "string"
				},
				"total_size": {
					"description": "TotalSize is the size in bytes of the record set.",
					"format": "int64",
					"type": "string"
				},
				"updated_date_time": {
					"description": "UpdatedDateTime is date time of when the recordset was last updated (renamed).",
					"format": "date-time",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Recordsets.RenameBody": {
			"description": "RenameRequest is the information provided when renaming a recordset.",
			"properties": {
				"new_name": {
					"description": "The new name of the recordset. Valid characters are alphanumeric, '_', '-', ' '.",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Recordsets.RenameResponse": {
			"description": "RenameResponse returns the renamed recordset.",
			"properties": {
				"recordset": {
					"allOf": [
						{
							"$ref": "#/definitions/Recordsets.Recordset"
						}
					],
					"description": "The Recordset overview, presenting an overview of the Recordset data."
				}
			},
			"type": "object"
		},
		"Recordsets.ValueType": {
			"default": "VALUE_TYPE_INVALID",
			"description": "ValueType is the type of data stored in each column.",
			"enum": [
				"VALUE_TYPE_INVALID",
				"BYTES",
				"STRING",
				"INTEGER",
				"FLOAT",
				"BOOL",
				"BYTES_SET",
				"INTEGER_ARRAY",
				"INTEGER_RANGE",
				"INTEGER_SET",
				"STRING_ARRAY",
				"STRING_SET",
				"FLOAT_ARRAY",
				"TIMESTAMP",
				"TIMESTAMP_ARRAY"
			],
			"type": "string"
		},
		"Region": {
			"default": "UNKNOWN",
			"description": "Region enumerates the supported cloud providers and locations.\n\n - UNKNOWN: UNKNOWN means the region has not been defined.\n - AWS_EU_WEST_2: AWS_EU_WEST_2 means AWS Europe (London).\n - AWS_US_EAST_1: AWS_US_EAST_1 means AWS US East (N. Virginia).\n - IBM_EU_CENTRAL_1: IBM_EU_CENTRAL_1 means IBM MZR EU Central (Frankfurt).\n - AWS_EU_CENTRAL_1: AWS_EU_CENTRAL_1 means AWS Europe (Frankfurt).\n - AWS_AP_SOUTHEAST_2: AWS_AP_SOUTHEAST_2 means AWS Asia Pacific (Sydney)",
			"enum": [
				"UNKNOWN",
				"AWS_EU_WEST_2",
				"AWS_US_EAST_1",
				"IBM_EU_CENTRAL_1",
				"AWS_EU_CENTRAL_1",
				"AWS_AP_SOUTHEAST_2"
			],
			"type": "string"
		},
		"Reports.CreateRequest": {
			"description": "CreateRequest is the Create rpc input.",
			"properties": {
				"baseline": {
					"allOf": [
						{
							"$ref": "#/definitions/Reports.DatasetOrAudienceID"
						}
					],
					"description": "Baseline defines the dataset/audience to be used as the baseline data."
				},
				"baseline_filter": {
					"description": "An IQL filter to define how to filter the baseline.",
					"type": "string"
				},
				"categories": {
					"description": "The list names of categories to include in the insight report.",
					"items": {
						"type": "string"
					},
					"type": "array"
				},
				"name": {
					"description": "Name is the user given name to assign to a insight report.",
					"type": "string"
				},
				"seed": {
					"allOf": [
						{
							"$ref": "#/definitions/Reports.DatasetOrAudienceID"
						}
					],
					"description": "Seed defines the dataset/audience to be used as the seed data."
				},
				"seed_filter": {
					"description": "An IQL filter to define how to filter the seed.",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Reports.CreateResponse": {
			"description": "CreateResponse is the rpc response for Create.",
			"properties": {
				"report_id": {
					"description": "ReportID is the unique ID generated for the insight report.",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Reports.DatasetOrAudienceID": {
			"properties": {
				"dataset_id": {
					"description": "The dataset to use as the data source.",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Reports.DeleteResponse": {
			"description": "DeleteResponse is the Delete rpc response.",
			"type": "object"
		},
		"Reports.DoubleCategoryResult": {
			"properties": {
				"baseline_background": {
					"description": "The count of all rows within the baseline that contain any value for the result categories.",
					"format": "int64",
					"type": "string"
				},
				"category_name_1": {
					"description": "The name of the first category in the result.",
					"type": "string"
				},
				"category_name_2": {
					"description": "The name of the second category in the result.",
					"type": "string"
				},
				"intersection_background": {
					"description": "The count of all rows within the seed-baseline intersection that contain any value for the result categories.",
					"format": "int64",
					"type": "string"
				},
				"values": {
					"description": "The results for each combination of category values for the result.",
					"items": {
						"$ref": "#/definitions/Reports.DoubleValueResult",
						"type": "object"
					},
					"type": "array"
				}
			},
			"type": "object"
		},
		"Reports.DoubleValueResult": {
			"properties": {
				"baseline_foreground": {
					"description": "The count of all rows within the baseline that contain the specific category value.",
					"format": "int64",
					"type": "string"
				},
				"category_value_1": {
					"description": "The value of category 1 for the result.",
					"type": "string"
				},
				"category_value_2": {
					"description": "The value of category 2 for the result.",
					"type": "string"
				},
				"index": {
					"description": "The index score calculated for the result.",
					"format": "int32",
					"type": "integer"
				},
				"intersection_foreground": {
					"description": "The count of all rows within the seed-baseline intersection that contain the specific category value.",
					"format": "int64",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Reports.GetCrossCategoryResultResponse": {
			"properties": {
				"result": {
					"allOf": [
						{
							"$ref": "#/definitions/Reports.DoubleCategoryResult"
						}
					],
					"description": "The results for the possible combinations for the specified categories."
				}
			},
			"type": "object"
		},
		"Reports.GetDefinitionResponse": {
			"description": "GetDefinitionResponse is the rpc response for Get.",
			"properties": {
				"baseline": {
					"allOf": [
						{
							"$ref": "#/definitions/Reports.DatasetOrAudienceID"
						}
					],
					"description": "The source of the baseline data."
				},
				"baseline_filter": {
					"description": "An IQL filter defining how the baseline was filtered.",
					"type": "string"
				},
				"categories": {
					"description": "The categories included in the report.",
					"items": {
						"type": "string"
					},
					"type": "array"
				},
				"created_by": {
					"description": "The user ID of the user who created the insight report.",
					"type": "string"
				},
				"created_date_time": {
					"description": "The datetime the insight report was created.",
					"format": "date-time",
					"type": "string"
				},
				"error": {
					"allOf": [
						{
							"$ref": "#/definitions/Error"
						}
					],
					"description": "The error that caused a report to fail. Empty if report has not failed."
				},
				"owner_id": {
					"description": "The ID for the company that owns the insight report.",
					"type": "string"
				},
				"report_id": {
					"description": "Uniquely specifies an insight report.",
					"type": "string"
				},
				"report_name": {
					"description": "The user given name for the insight report.",
					"type": "string"
				},
				"seed": {
					"allOf": [
						{
							"$ref": "#/definitions/Reports.DatasetOrAudienceID"
						}
					],
					"description": "The source of the seed data."
				},
				"seed_filter": {
					"description": "An IQL filter defining how to the seed was filtered.",
					"type": "string"
				},
				"status": {
					"allOf": [
						{
							"$ref": "#/definitions/Reports.v1.Status"
						}
					],
					"description": "The status of report generation."
				}
			},
			"type": "object"
		},
		"Reports.GetStatusResponse": {
			"description": "GetStatusResponse is the GetStatus rpc response.",
			"properties": {
				"error": {
					"allOf": [
						{
							"$ref": "#/definitions/Error"
						}
					],
					"description": "The error that caused a report to fail. Empty if report has not failed."
				},
				"progress": {
					"allOf": [
						{
							"$ref": "#/definitions/Reports.Progress"
						}
					],
					"description": "The progress of the queries required to generate the report."
				},
				"status": {
					"allOf": [
						{
							"$ref": "#/definitions/Reports.v1.Status"
						}
					],
					"description": "The status of report generation."
				}
			},
			"type": "object"
		},
		"Reports.InsightReportSummary": {
			"description": "InsightReportSummary is report details returned from the List rpc.",
			"properties": {
				"created_by": {
					"description": "The ID of the user who created the insight report.",
					"type": "string"
				},
				"created_date_time": {
					"description": "The datetime the insight report was created.",
					"format": "date-time",
					"type": "string"
				},
				"owner_id": {
					"description": "The ID for the entity that owns the insight report.",
					"type": "string"
				},
				"progress": {
					"allOf": [
						{
							"$ref": "#/definitions/Reports.Progress"
						}
					],
					"description": "The progress of the queries required to generate the report."
				},
				"report_id": {
					"description": "Uniquely specifies an insight report.",
					"type": "string"
				},
				"report_name": {
					"description": "The user given name for the insight report.",
					"type": "string"
				},
				"report_type": {
					"description": "The type of the report.",
					"type": "string"
				},
				"status": {
					"allOf": [
						{
							"$ref": "#/definitions/Reports.v1.Status"
						}
					],
					"description": "The status of report generation."
				}
			},
			"type": "object"
		},
		"Reports.ListResponse": {
			"description": "ListResponse is the response for the List rpc.",
			"properties": {
				"pagination": {
					"allOf": [
						{
							"$ref": "#/definitions/PaginationResponse"
						}
					],
					"description": "The pagination details of the returned insight reports."
				},
				"reports": {
					"description": "A list of insight reports.",
					"items": {
						"$ref": "#/definitions/Reports.InsightReportSummary",
						"type": "object"
					},
					"type": "array"
				}
			},
			"type": "object"
		},
		"Reports.ListSinglesResultsResponse": {
			"description": "ListSinglesResultsResponse is the ListResults rpc response.",
			"properties": {
				"pagination": {
					"allOf": [
						{
							"$ref": "#/definitions/PaginationResponse"
						}
					],
					"description": "The pagination details of the returned insight report results."
				},
				"results": {
					"description": "The results for the specified insight report.",
					"items": {
						"$ref": "#/definitions/Reports.SingleCategoryResult",
						"type": "object"
					},
					"type": "array"
				}
			},
			"type": "object"
		},
		"Reports.Progress": {
			"description": "Progress holds the information of the progress of the a report generation.",
			"properties": {
				"completion_percentage": {
					"description": "The progress to completion as a percentage.",
					"format": "float",
					"type": "number"
				}
			},
			"type": "object"
		},
		"Reports.SingleCategoryResult": {
			"properties": {
				"baseline_background": {
					"description": "The count of all rows within the baseline that contain any value for the category.",
					"format": "int64",
					"type": "string"
				},
				"category_name": {
					"description": "The name of the category.",
					"type": "string"
				},
				"intersection_background": {
					"description": "The count of all rows within the seed-baseline intersection that contain any value for the category.",
					"format": "int64",
					"type": "string"
				},
				"values": {
					"items": {
						"$ref": "#/definitions/Reports.SingleValueResult",
						"type": "object"
					},
					"type": "array"
				}
			},
			"type": "object"
		},
		"Reports.SingleValueResult": {
			"properties": {
				"baseline_foreground": {
					"description": "The count of all rows within the baseline that contain the specific category value.",
					"format": "int64",
					"type": "string"
				},
				"category_value": {
					"description": "The value within the category.",
					"type": "string"
				},
				"index": {
					"description": "The index score calculated for the result.",
					"format": "int32",
					"type": "integer"
				},
				"intersection_foreground": {
					"description": "The count of all rows within the seed-baseline intersection that contain the specific category value.",
					"format": "int64",
					"type": "string"
				}
			},
			"type": "object"
		},
		"Reports.v1.Status": {
			"default": "NO_STATUS",
			"description": "Status is an enum of the different states that an async task can be in.",
			"enum": [
				"NO_STATUS",
				"WAITING",
				"INITIALIZING",
				"RUNNING",
				"FAILED",
				"COMPLETED",
				"CANCELING",
				"CANCELED",
				"STALE",
				"PROVISIONING",
				"PROVISIONED",
				"PARTIALLY_COMPLETED"
			],
			"type": "string"
		},
		"v2.CloudVault": {
			"description": "CloudVault is the details about a specific Cloud Vault.",
			"properties": {
				"created_by": {
					"description": "Output only. CreatedBy is the id of the user that created this Cloud Vault.",
					"readOnly": true,
					"type": "string"
				},
				"created_date_time": {
					"description": "Output only. CreatedDateTime is the date and time that this Cloud Vault was\ncreated.",
					"format": "date-time",
					"readOnly": true,
					"type": "string"
				},
				"description": {
					"description": "Description is an optional description given to this Cloud Vault.",
					"type": "string"
				},
				"id": {
					"description": "Output only. ID is the unique identifier of the Cloud Vault.",
					"readOnly": true,
					"type": "string"
				},
				"name": {
					"description": "Name is the display name given to this Cloud Vault.",
					"type": "string"
				},
				"owner_id": {
					"description": "Output only. OwnerId is the id of the owner of this Cloud Vault.",
					"readOnly": true,
					"type": "string"
				},
				"region": {
					"allOf": [
						{
							"$ref": "#/definitions/Region"
						}
					],
					"description": "Output only. Region identifies the region that this Cloud Vault is located\nin.",
					"readOnly": true
				},
				"updated_date_time": {
					"format": "date-time",
					"readOnly": true,
					"title": "Output only. UpdatedDateTime is the date and time that the Cloud Vault was\nupdated",
					"type": "string"
				}
			},
			"type": "object"
		}
	},
	"externalDocs": {
		"description": "Official Documentation",
		"url": "https://infosum.github.io/infosum-docs/"
	},
	"host": "api.infosum.com",
	"info": {
		"contact": {
			"email": "support@infosum.com",
			"name": "InfoSum Support"
		},
		"description": "This page contains the documentation for the InfoSum Developer API. The methods allow you to try making requests and inspect the input and output formats.",
		"termsOfService": "https://www.infosum.com/legals/website-terms",
		"title": "InfoSum Developer API",
		"version": "2.0"
	},
	"paths": {
		"/api/v2/accounts/companies/display_name": {
			"get": {
				"description": "Get a company's display name.",
				"operationId": "GetCompanyDisplayName",
				"parameters": [
					{
						"description": "The ID of the company to look up the display name for.",
						"in": "query",
						"name": "company_id",
						"required": false,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Accounts.GetCompanyDisplayNameResponse"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"404": {
						"description": "Returned when the Company ID could not be found.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Get a company's display name.",
				"tags": [
					"Accounts"
				]
			}
		},
		"/api/v2/accounts/me": {
			"get": {
				"description": "Get a user's account details .",
				"operationId": "GetAccountInformation",
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Accounts.GetAccountInformationResponse"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Get a user's account details.",
				"tags": [
					"Accounts"
				]
			}
		},
		"/api/v2/accounts/users/display_name": {
			"get": {
				"description": "List users' display name and company name.",
				"operationId": "ListDisplayNames",
				"parameters": [
					{
						"description": "The requested page of records. Default is 1.",
						"format": "int32",
						"in": "query",
						"name": "pagination.page",
						"required": false,
						"type": "integer"
					},
					{
						"description": "The number of records to return per page. Maximum is 500. Default is 100.",
						"format": "int32",
						"in": "query",
						"name": "pagination.per_page",
						"required": false,
						"type": "integer"
					},
					{
						"description": "The filter to restrict the list of returned users.",
						"in": "query",
						"name": "filter",
						"required": false,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Accounts.ListDisplayNamesResponse"
						}
					},
					"400": {
						"description": "Returned when the ListDisplayNames request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "List users' display name and company name.",
				"tags": [
					"Accounts"
				]
			}
		},
		"/api/v2/activations/queries/{query_id}/destinations": {
			"get": {
				"description": "List the destinations which can be used for the provided activation query.",
				"operationId": "ListActivationDestinations",
				"parameters": [
					{
						"description": "QueryID is the activation query ID to get valid destination targets for.",
						"in": "path",
						"name": "query_id",
						"required": true,
						"type": "string"
					},
					{
						"description": "The requested page of records. Default is 1.",
						"format": "int32",
						"in": "query",
						"name": "pagination.page",
						"required": false,
						"type": "integer"
					},
					{
						"description": "The number of records to return per page. Maximum is 500. Default is 100.",
						"format": "int32",
						"in": "query",
						"name": "pagination.per_page",
						"required": false,
						"type": "integer"
					},
					{
						"description": "OrderBy specifies ordering parameters. Valid parameters are: name, created_time, destination_type_id. Default: created_time DESC",
						"in": "query",
						"name": "order_by",
						"required": false,
						"type": "string"
					},
					{
						"description": "Supported filters are `owner_id`, `recipient_company_id`, `destination_id`",
						"in": "query",
						"name": "filter",
						"required": false,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Activation_Destinations.ListActivationDestinationsResponse"
						}
					},
					"400": {
						"description": "Returned when the request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "List Activation Destinations",
				"tags": [
					"Activation Destinations"
				]
			}
		},
		"/api/v2/activations/queries/{query_id}/destinations/{destination_id}/push": {
			"post": {
				"description": "Pushes results of a query to a specific destination instance.",
				"operationId": "PushActivationResults",
				"parameters": [
					{
						"description": "ID of the activation query.",
						"in": "path",
						"name": "query_id",
						"required": true,
						"type": "string"
					},
					{
						"description": "Destination instance ID.",
						"in": "path",
						"name": "destination_id",
						"required": true,
						"type": "string"
					},
					{
						"in": "body",
						"name": "body",
						"required": true,
						"schema": {
							"$ref": "#/definitions/Activation_Destinations.PushActivationResultsBody"
						}
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Activation_Destinations.PushActivationResultsResponse"
						}
					},
					"400": {
						"description": "Returned when the request is invalid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the right to push to the destination instance.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"404": {
						"description": "Returned when the destination instance, query or the dataset does not exist.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Push Activation Result to Destination",
				"tags": [
					"Activation Destinations"
				]
			}
		},
		"/api/v2/activations/queries/{query_id}/destinations/{destination_id}/push-schema": {
			"get": {
				"description": "Returns the push time schema for a specific destination instance subject to constraints (like query ID).",
				"operationId": "GetActivationDestinationPushSchema",
				"parameters": [
					{
						"description": "ID of the Activation Query to be pushed.",
						"in": "path",
						"name": "query_id",
						"required": true,
						"type": "string"
					},
					{
						"description": "Destination instance ID.",
						"in": "path",
						"name": "destination_id",
						"required": true,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Activation_Destinations.GetActivationDestinationPushSchemaResponse"
						}
					},
					"400": {
						"description": "Returned when the request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the right to view Destinations.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"404": {
						"description": "Returned when the Destination instance or query could not be found.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Get Activation Destination Push Schema",
				"tags": [
					"Activation Destinations"
				]
			}
		},
		"/api/v2/activations/queries/{query_id}/pushes": {
			"get": {
				"description": "Returns a list of pushes for the specified activation query.",
				"operationId": "ListActivationPushes",
				"parameters": [
					{
						"description": "The activation query ID.",
						"in": "path",
						"name": "query_id",
						"required": true,
						"type": "string"
					},
					{
						"description": "OrderBy is a comma seperated value to define sorting.\ne.g 'destination_type,started_at_date_time DESC'\nThe values are seperated by space, '{column} {ASC/DESC}'",
						"in": "query",
						"name": "order_by",
						"required": false,
						"type": "string"
					},
					{
						"description": "Filter is a string containing logic that can specify a restricted set of Pushes to be returned.\ne.g. 'destination_id eq a_specific_destination_id' or 'push_successful eq true'",
						"in": "query",
						"name": "filter",
						"required": false,
						"type": "string"
					},
					{
						"description": "The requested page of records. Default is 1.",
						"format": "int32",
						"in": "query",
						"name": "pagination.page",
						"required": false,
						"type": "integer"
					},
					{
						"description": "The number of records to return per page. Maximum is 500. Default is 100.",
						"format": "int32",
						"in": "query",
						"name": "pagination.per_page",
						"required": false,
						"type": "integer"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Activation_Pushes.ListActivationPushesResponse"
						}
					},
					"400": {
						"description": "Returned when the request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the right to view Activations.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"404": {
						"description": "Returned when the activation query is not found.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "List Activation Query Pushes",
				"tags": [
					"Activation Pushes"
				]
			}
		},
		"/api/v2/activations/queries/{query_id}/pushes/{push_id}": {
			"get": {
				"description": "Returns the details for a specific activation push subject to constraints (like query ID).",
				"operationId": "GetActivationPush",
				"parameters": [
					{
						"description": "The ID of the query that has been pushed.",
						"in": "path",
						"name": "query_id",
						"required": true,
						"type": "string"
					},
					{
						"description": "The ID of the activation push.",
						"in": "path",
						"name": "push_id",
						"required": true,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Activation_Pushes.GetActivationPushResponse"
						}
					},
					"400": {
						"description": "Returned when the request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the right to view Activations.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"404": {
						"description": "Returned when either the query or the activation push cannot be found.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Get Activation Query Push",
				"tags": [
					"Activation Pushes"
				]
			}
		},
		"/api/v2/automations/configs": {
			"get": {
				"description": "Lists configs belonging to your company subject to the provided filter.",
				"operationId": "ListConfigs",
				"parameters": [
					{
						"description": "The requested page of records. Default is 1.",
						"format": "int32",
						"in": "query",
						"name": "pagination.page",
						"required": false,
						"type": "integer"
					},
					{
						"description": "The number of records to return per page. Maximum is 500. Default is 100.",
						"format": "int32",
						"in": "query",
						"name": "pagination.per_page",
						"required": false,
						"type": "integer"
					},
					{
						"default": "updated_date_time DESC",
						"description": "Comma separated list of sorting parameters and ordering in the form of `{sort_column} {ASC/DESC}`. Supported sort fields are: `id`, `config_id`, `executed_by`, `started_date_time`, `last_updated_date_time`, `current_step`, `current_step_status`, `cloud_vault_id`.",
						"in": "query",
						"name": "order_by",
						"required": false,
						"type": "string"
					},
					{
						"description": "Filter string as per the [docs](https://infosum.github.io/infosum-docs/docs/v2%20API/filtering). Supported filter fields are: `id`, `config_id`, `executed_by`, `started_date_time`, `last_updated_date_time`, `current_step`, `current_step_status`, `cloud_vault_id`.",
						"in": "query",
						"name": "filter",
						"required": false,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Automation_Configs.ListConfigsResponse"
						}
					},
					"400": {
						"description": "Returned when the request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "List Automation Configs",
				"tags": [
					"Automation Configs"
				]
			},
			"post": {
				"description": "Creates and validates an Automation Config based on the provided list of ordered tasks.",
				"operationId": "CreateConfig",
				"parameters": [
					{
						"description": "CreateConfigRequest is the information provided when creating an Automation Config.",
						"in": "body",
						"name": "body",
						"required": true,
						"schema": {
							"$ref": "#/definitions/Automation_Configs.CreateConfigRequest"
						}
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Automation_Configs.CreateConfigResponse"
						}
					},
					"400": {
						"description": "Returned when the request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"404": {
						"description": "Returned when the data could not be found.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Create Automation Config",
				"tags": [
					"Automation Configs"
				]
			}
		},
		"/api/v2/automations/configs/{config_id}": {
			"delete": {
				"description": "Remove the specified Automation Config along with any execution information and history. No new executions can be triggered for deleted Automation Configs.",
				"operationId": "DeleteConfig",
				"parameters": [
					{
						"description": "The ID of the Automation Config to be deleted.",
						"in": "path",
						"name": "config_id",
						"required": true,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Automation_Configs.DeleteConfigResponse"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Delete Automation Config",
				"tags": [
					"Automation Configs"
				]
			},
			"get": {
				"description": "Fetches an Automation Config by its Config ID.",
				"operationId": "GetConfig",
				"parameters": [
					{
						"description": "The ID of the Automation Config to retrieve.",
						"in": "path",
						"name": "config_id",
						"required": true,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Automation_Configs.GetConfigResponse"
						}
					},
					"400": {
						"description": "Returned when the request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"404": {
						"description": "Returned when the Automation Config could not be found.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Get Automation Config",
				"tags": [
					"Automation Configs"
				]
			},
			"patch": {
				"description": "Updates the specified Automation Config, overriding any old fields with new ones provided on the request.",
				"operationId": "UpdateConfig",
				"parameters": [
					{
						"description": "The ID of the Automation Config to be updated.",
						"in": "path",
						"name": "config_id",
						"required": true,
						"type": "string"
					},
					{
						"description": "Config is the config the user wants to update.",
						"in": "body",
						"name": "config",
						"required": true,
						"schema": {
							"$ref": "#/definitions/Automation_Configs.v2.UpdateConfig",
							"description": "The Automation Config."
						}
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Automation_Configs.UpdateConfigResponse"
						}
					},
					"400": {
						"description": "Returned when the request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"404": {
						"description": "Returned when the Automation Config could not be found.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Update Automation Config",
				"tags": [
					"Automation Configs"
				]
			}
		},
		"/api/v2/automations/configs/{config_id}/execute": {
			"post": {
				"description": "Execute Automation Config manually initiates the Execution of an Automation Config ignoring its schedule.",
				"operationId": "Execute",
				"parameters": [
					{
						"description": "The ID of the Automation Config to manually trigger an Execution of.",
						"in": "path",
						"name": "config_id",
						"required": true,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Automation_Execution.ExecuteResponse"
						}
					},
					"400": {
						"description": "Returned when the request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"404": {
						"description": "Returned when the automation config could not be found.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Execute Automation Config",
				"tags": [
					"Automation Execution"
				]
			}
		},
		"/api/v2/automations/executions": {
			"get": {
				"description": "List Executions retrieves Automation Config Executions subject to the provided filters.",
				"operationId": "ListExecution",
				"parameters": [
					{
						"description": "The requested page of records. Default is 1.",
						"format": "int32",
						"in": "query",
						"name": "pagination.page",
						"required": false,
						"type": "integer"
					},
					{
						"description": "The number of records to return per page. Maximum is 500. Default is 100.",
						"format": "int32",
						"in": "query",
						"name": "pagination.per_page",
						"required": false,
						"type": "integer"
					},
					{
						"description": "OrderBy is a comma separated value to define sorting.\ne.g 'name,created_time DESC'.\nThe values are separated by space, '{column} {ASC/DESC}'.\nThese are the values that are sortable:\n  none",
						"in": "query",
						"name": "order_by",
						"required": false,
						"type": "string"
					},
					{
						"description": "Filter is a string containing logic that can specify a restricted set of\nRecordsets to be returned. e.g. `name co 'Test' or name co 'Acme'`. These are\nthe supported fields for filtering:\n  none",
						"in": "query",
						"name": "filter",
						"required": false,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Automation_Execution.ListExecutionResponse"
						}
					},
					"400": {
						"description": "Returned when the request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "List Executions",
				"tags": [
					"Automation Execution"
				]
			}
		},
		"/api/v2/automations/executions/{execution_id}": {
			"get": {
				"description": "Get Execution fetches details of an Automation Execution by its ID.",
				"operationId": "GetExecution",
				"parameters": [
					{
						"description": "The ID of the Automation Execution to retrieve.",
						"in": "path",
						"name": "execution_id",
						"required": true,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Automation_Execution.GetExecutionResponse"
						}
					},
					"400": {
						"description": "Returned when the request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"404": {
						"description": "Returned when the Automation Execution could not be found.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Get Execution",
				"tags": [
					"Automation Execution"
				]
			}
		},
		"/api/v2/cloud_vaults": {
			"get": {
				"description": "List available Cloud Vaults.",
				"operationId": "List",
				"parameters": [
					{
						"description": "The requested page of records. Default is 1.",
						"format": "int32",
						"in": "query",
						"name": "pagination.page",
						"required": false,
						"type": "integer"
					},
					{
						"description": "The number of records to return per page. Maximum is 500. Default is 100.",
						"format": "int32",
						"in": "query",
						"name": "pagination.per_page",
						"required": false,
						"type": "integer"
					},
					{
						"description": "OrderBy is a comma seperated value to define sorting.\ne.g 'name,created_time DESC'\nThe values are seperated by space, '{column} {ASC/DESC}'",
						"in": "query",
						"name": "order_by",
						"required": false,
						"type": "string"
					},
					{
						"description": "Filter is a string containing logic that can specify a restricted set of\nCloud Vaults to be returned. e.g. `name co 'Test' or name co 'Acme'`",
						"in": "query",
						"name": "filter",
						"required": false,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Cloud_Vaults.ListResponse"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "List Cloud Vaults.",
				"tags": [
					"Cloud Vaults"
				]
			},
			"post": {
				"description": "Create a Cloud Vault to hold data and connect to a bunker.",
				"operationId": "Create",
				"parameters": [
					{
						"in": "body",
						"name": "body",
						"required": true,
						"schema": {
							"$ref": "#/definitions/Cloud_Vaults.CreateRequest"
						}
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Cloud_Vaults.CreateResponse"
						}
					},
					"400": {
						"description": "Returned when the Cloud Vault was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"409": {
						"description": "Returned when a Cloud Vault with the same name already exists.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Create a new Cloud Vault.",
				"tags": [
					"Cloud Vaults"
				]
			}
		},
		"/api/v2/cloud_vaults/{cloud_vault.id}": {
			"patch": {
				"description": "Updates the provided fields in a specific Cloud Vault.",
				"operationId": "Update",
				"parameters": [
					{
						"description": "Output only. ID is the unique identifier of the Cloud Vault.",
						"in": "path",
						"name": "cloud_vault.id",
						"required": true,
						"type": "string"
					},
					{
						"in": "body",
						"name": "cloud_vault",
						"required": true,
						"schema": {
							"description": "UpdateCloudVault is used to update a Cloud Vault. Users can only update the\nname, description and auth fields.",
							"properties": {
								"description": {
									"description": "Description is an optional description given to this Cloud Vault.",
									"type": "string"
								},
								"name": {
									"description": "Name is the display name given to this Cloud Vault.",
									"type": "string"
								}
							},
							"type": "object"
						}
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Cloud_Vaults.UpdateResponse"
						}
					},
					"400": {
						"description": "Returned when the request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"404": {
						"description": "Returned when the Cloud Vault could not be found.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Update a Cloud Vault",
				"tags": [
					"Cloud Vaults"
				]
			}
		},
		"/api/v2/cloud_vaults/{id}": {
			"delete": {
				"description": "Deletes a specific Cloud Vault.",
				"operationId": "Delete",
				"parameters": [
					{
						"in": "path",
						"name": "id",
						"required": true,
						"type": "string"
					},
					{
						"description": "Force will, if set, delete a Cloud Vault that is associated with a bunker or\nis currently in use. If it is not set, an error will be returned in these cases\ninstead.",
						"in": "query",
						"name": "force",
						"required": false,
						"type": "boolean"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Cloud_Vaults.DeleteResponse"
						}
					},
					"400": {
						"description": "Returned when the request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Delete a Cloud Vault.",
				"tags": [
					"Cloud Vaults"
				]
			},
			"get": {
				"description": "Get the details of a specific Cloud Vault.",
				"operationId": "Get",
				"parameters": [
					{
						"in": "path",
						"name": "id",
						"required": true,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Cloud_Vaults.GetResponse"
						}
					},
					"400": {
						"description": "Returned when the request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"404": {
						"description": "Returned when the Cloud Vault could not be found.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Get a Cloud Vault.",
				"tags": [
					"Cloud Vaults"
				]
			}
		},
		"/api/v2/connections/pair/match-rate": {
			"post": {
				"description": "Calculates the match rate between two PAIR enabled datasets.",
				"operationId": "CalculateMatchRate",
				"parameters": [
					{
						"description": "CalculateMatchRateRequest is the input to the CalculateMatchRate method.",
						"in": "body",
						"name": "body",
						"required": true,
						"schema": {
							"$ref": "#/definitions/Connections.CalculateMatchRateRequest"
						}
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Connections.CalculateMatchRateResponse"
						}
					},
					"400": {
						"description": "Returned when the request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Calculate match rate",
				"tags": [
					"Connections"
				]
			}
		},
		"/api/v2/dataset-prepare-configs": {
			"get": {
				"description": "List company dataset prepare configurations",
				"operationId": "ListConfigs",
				"parameters": [
					{
						"description": "The requested page of records. Default is 1.",
						"format": "int32",
						"in": "query",
						"name": "pagination.page",
						"required": false,
						"type": "integer"
					},
					{
						"description": "The number of records to return per page. Maximum is 500. Default is 100.",
						"format": "int32",
						"in": "query",
						"name": "pagination.per_page",
						"required": false,
						"type": "integer"
					},
					{
						"description": "OrderBy is a comma seperated value to define sorting.\ne.g 'name,created_time DESC'\nThe values are seperated by space, '{column} {ASC/DESC}'\n\nThe following values are permitted:\n    name\n    created_date_time (RFC3339 format)\n    updated_date_time (RFC3339 format)",
						"in": "query",
						"name": "order_by",
						"required": false,
						"type": "string"
					},
					{
						"description": "Filter is a string containing logic that can specify a restricted set of\nCloud Vaults to be returned. e.g. `name co 'Test' or name co 'Acme'`\n\nThe following values are permitted:\n    name\n    created_date_time (RFC3339 format)\n    updated_date_time (RFC3339 format)",
						"in": "query",
						"name": "filter",
						"required": false,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Prepare_Configs.ListConfigsResponse"
						}
					},
					"400": {
						"description": "Returned when the ListConfigs request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "List company Dataset Prepare Configurations.",
				"tags": [
					"Prepare Configs"
				]
			},
			"post": {
				"description": "Creates a reusable dataset prepare config",
				"operationId": "CreateConfig",
				"parameters": [
					{
						"in": "body",
						"name": "body",
						"required": true,
						"schema": {
							"$ref": "#/definitions/Prepare_Configs.CreateConfigRequest"
						}
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Prepare_Configs.CreateConfigResponse"
						}
					},
					"400": {
						"description": "Returned when the CreateConfigRequest request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Creates a reusable dataset prepare config.",
				"tags": [
					"Prepare Configs"
				]
			}
		},
		"/api/v2/dataset-prepare-configs/{config_id}": {
			"delete": {
				"description": "Delete a dataset prepare config",
				"operationId": "DeleteConfig",
				"parameters": [
					{
						"description": "ConfigID is the ID of the Dataset Prepare Configuration the user wants to delete.",
						"in": "path",
						"name": "config_id",
						"required": true,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Prepare_Configs.DeleteConfigResponse"
						}
					},
					"400": {
						"description": "Returned when the DeleteConfig request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Delete a Dataset Prepare Config.",
				"tags": [
					"Prepare Configs"
				]
			},
			"get": {
				"description": "Get a dataset prepare configuration",
				"operationId": "GetConfig",
				"parameters": [
					{
						"description": "ConfigID is the ID of the dataset prepare configuration the user wants to get.",
						"in": "path",
						"name": "config_id",
						"required": true,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Prepare_Configs.GetConfigResponse"
						}
					},
					"400": {
						"description": "Returned when the GetConfig request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"404": {
						"description": "Returned when the dataset prepare config could not be found.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Get a Dataset Prepare Configuration.",
				"tags": [
					"Prepare Configs"
				]
			},
			"put": {
				"description": "Update a dataset prepare configuration",
				"operationId": "UpdateConfig",
				"parameters": [
					{
						"description": "ConfigID is the ID of the dataset prepare config the user wants to update.",
						"in": "path",
						"name": "config_id",
						"required": true,
						"type": "string"
					},
					{
						"in": "body",
						"name": "body",
						"required": true,
						"schema": {
							"$ref": "#/definitions/Prepare_Configs.UpdateConfigBody"
						}
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Prepare_Configs.UpdateConfigResponse"
						}
					},
					"400": {
						"description": "Returned when the GetConfig request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"404": {
						"description": "Returned when the dataset prepare config could not be found.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Update a Dataset Prepare Configuration.",
				"tags": [
					"Prepare Configs"
				]
			}
		},
		"/api/v2/dataset-prepare-configs/{config_id}/categories": {
			"delete": {
				"description": "Delete categories with a filter from a dataset prepare config",
				"operationId": "DeleteConfigCategories",
				"parameters": [
					{
						"description": "ConfigID is the ID of the dataset prepare config the user wants to delete categories from.",
						"in": "path",
						"name": "config_id",
						"required": true,
						"type": "string"
					},
					{
						"description": "Filter specifies which subset of categories to delete",
						"in": "query",
						"name": "filter",
						"required": false,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Prepare_Configs.DeleteConfigCategoriesResponse"
						}
					},
					"400": {
						"description": "Returned when the DeleteConfig request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Delete categories with a filter from a Dataset Prepare Config.",
				"tags": [
					"Prepare Configs"
				]
			},
			"get": {
				"description": "List the categories for a dataset prepare configuration",
				"operationId": "ListConfigCategories",
				"parameters": [
					{
						"description": "ConfigID is the ID of the dataset prepare config the user wants to list.",
						"in": "path",
						"name": "config_id",
						"required": true,
						"type": "string"
					},
					{
						"description": "The requested page of records. Default is 1.",
						"format": "int32",
						"in": "query",
						"name": "pagination.page",
						"required": false,
						"type": "integer"
					},
					{
						"description": "The number of records to return per page. Maximum is 500. Default is 100.",
						"format": "int32",
						"in": "query",
						"name": "pagination.per_page",
						"required": false,
						"type": "integer"
					},
					{
						"description": "OrderBy is a comma seperated value to define sorting.\ne.g 'name,created_time DESC'\nThe values are seperated by space, '{column} {ASC/DESC}'\n\nThe following values are permitted:\n    name\n    created_date_time (RFC3339 format)\n    updated_date_time (RFC3339 format)",
						"in": "query",
						"name": "order_by",
						"required": false,
						"type": "string"
					},
					{
						"description": "Filter is a string containing logic that can specify a restricted set of\ncategories to be returned.\n\nThe following values are permitted:\n    name\n    created_date_time (RFC3339 format)\n    updated_date_time (RFC3339 format)",
						"in": "query",
						"name": "filter",
						"required": false,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Prepare_Configs.ListConfigCategoriesResponse"
						}
					},
					"400": {
						"description": "Returned when the ListConfigKeys request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"404": {
						"description": "Returned when the dataset prepare config could not be found.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "List the categories for a Dataset Prepare Configuration.",
				"tags": [
					"Prepare Configs"
				]
			},
			"post": {
				"description": "Add a category to a dataset prepare configuration",
				"operationId": "AddConfigCategories",
				"parameters": [
					{
						"description": "ConfigID is the ID of the dataset prepare config the user wants to add categories to.",
						"in": "path",
						"name": "config_id",
						"required": true,
						"type": "string"
					},
					{
						"in": "body",
						"name": "body",
						"required": true,
						"schema": {
							"$ref": "#/definitions/Prepare_Configs.AddConfigCategoriesBody"
						}
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Prepare_Configs.AddConfigCategoriesResponse"
						}
					},
					"400": {
						"description": "Returned when the AddConfigCategory request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"404": {
						"description": "Returned when the dataset prepare config could not be found.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Add a category to a Dataset Prepare Configuration.",
				"tags": [
					"Prepare Configs"
				]
			}
		},
		"/api/v2/dataset-prepare-configs/{config_id}/export-columns": {
			"delete": {
				"description": "Delete export columns with a filter from a dataset prepare config",
				"operationId": "DeleteConfigExportColumns",
				"parameters": [
					{
						"description": "ConfigID is the ID of the dataset prepare config the user wants to delete export columns from.",
						"in": "path",
						"name": "config_id",
						"required": true,
						"type": "string"
					},
					{
						"description": "Filter specifies which subset of export columns to delete",
						"in": "query",
						"name": "filter",
						"required": false,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Prepare_Configs.DeleteConfigExportColumnsResponse"
						}
					},
					"400": {
						"description": "Returned when the DeleteConfig request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Delete export columns with a filter from a Dataset Prepare Config.",
				"tags": [
					"Prepare Configs"
				]
			},
			"get": {
				"description": "List the export columns for a dataset prepare configuration",
				"operationId": "ListConfigExportColumns",
				"parameters": [
					{
						"description": "ConfigID is the ID of the dataset prepare config the user wants to list.",
						"in": "path",
						"name": "config_id",
						"required": true,
						"type": "string"
					},
					{
						"description": "The requested page of records. Default is 1.",
						"format": "int32",
						"in": "query",
						"name": "pagination.page",
						"required": false,
						"type": "integer"
					},
					{
						"description": "The number of records to return per page. Maximum is 500. Default is 100.",
						"format": "int32",
						"in": "query",
						"name": "pagination.per_page",
						"required": false,
						"type": "integer"
					},
					{
						"description": "OrderBy is a comma seperated value to define sorting.\ne.g 'name,created_time DESC'\nThe values are seperated by space, '{column} {ASC/DESC}'\n\nThe following values are permitted:\n    name\n    created_date_time (RFC3339 format)\n    updated_date_time (RFC3339 format)",
						"in": "query",
						"name": "order_by",
						"required": false,
						"type": "string"
					},
					{
						"description": "Filter is a string containing logic that can specify a restricted set of\nexport columns to be returned.\n\nThe following values are permitted:\n    name\n    created_date_time (RFC3339 format)\n    updated_date_time (RFC3339 format)",
						"in": "query",
						"name": "filter",
						"required": false,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Prepare_Configs.ListConfigExportColumnsResponse"
						}
					},
					"400": {
						"description": "Returned when the ListConfigKeys request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"404": {
						"description": "Returned when the dataset prepare config could not be found.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "List the export columns for a Dataset Prepare Configuration.",
				"tags": [
					"Prepare Configs"
				]
			},
			"post": {
				"description": "Add an export column to a dataset prepare configuration",
				"operationId": "AddConfigExportColumns",
				"parameters": [
					{
						"description": "ConfigID is the ID of the dataset prepare config the user wants to add export columns to.",
						"in": "path",
						"name": "config_id",
						"required": true,
						"type": "string"
					},
					{
						"in": "body",
						"name": "body",
						"required": true,
						"schema": {
							"$ref": "#/definitions/Prepare_Configs.AddConfigExportColumnsBody"
						}
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Prepare_Configs.AddConfigExportColumnsResponse"
						}
					},
					"400": {
						"description": "Returned when the AddConfigExportColumn request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"404": {
						"description": "Returned when the dataset prepare config could not be found.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Add an export column to a Dataset Prepare Configuration.",
				"tags": [
					"Prepare Configs"
				]
			}
		},
		"/api/v2/dataset-prepare-configs/{config_id}/keys": {
			"delete": {
				"description": "Delete a key from a dataset prepare config",
				"operationId": "DeleteConfigKeys",
				"parameters": [
					{
						"description": "ConfigID is the ID of the dataset prepare config the user wants to delete keys from.",
						"in": "path",
						"name": "config_id",
						"required": true,
						"type": "string"
					},
					{
						"description": "Filter specifies which subset of keys to delete",
						"in": "query",
						"name": "filter",
						"required": false,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Prepare_Configs.DeleteConfigKeysResponse"
						}
					},
					"400": {
						"description": "Returned when the DeleteConfig request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Delete a key from a Dataset Prepare Config.",
				"tags": [
					"Prepare Configs"
				]
			},
			"get": {
				"description": "List the keys for a dataset prepare configuration",
				"operationId": "ListConfigKeys",
				"parameters": [
					{
						"description": "ConfigID is the ID of the dataset prepare config the user wants to list.",
						"in": "path",
						"name": "config_id",
						"required": true,
						"type": "string"
					},
					{
						"description": "The requested page of records. Default is 1.",
						"format": "int32",
						"in": "query",
						"name": "pagination.page",
						"required": false,
						"type": "integer"
					},
					{
						"description": "The number of records to return per page. Maximum is 500. Default is 100.",
						"format": "int32",
						"in": "query",
						"name": "pagination.per_page",
						"required": false,
						"type": "integer"
					},
					{
						"description": "OrderBy is a comma seperated value to define sorting.\ne.g 'name,created_time DESC'\nThe values are seperated by space, '{column} {ASC/DESC}'\n\nThe following values are permitted:\n    name\n    created_date_time (RFC3339 format)\n    updated_date_time (RFC3339 format)",
						"in": "query",
						"name": "order_by",
						"required": false,
						"type": "string"
					},
					{
						"description": "Filter is a string containing logic that can specify a restricted set of\nkeys to be returned.\n\nThe following values are permitted:\n    name\n    created_date_time (RFC3339 format)\n    updated_date_time (RFC3339 format)",
						"in": "query",
						"name": "filter",
						"required": false,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Prepare_Configs.ListConfigKeysResponse"
						}
					},
					"400": {
						"description": "Returned when the ListConfigKeys request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"404": {
						"description": "Returned when the dataset prepare config could not be found.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "List the keys for a Dataset Prepare Configuration.",
				"tags": [
					"Prepare Configs"
				]
			},
			"post": {
				"description": "Add a key to a dataset prepare configuration",
				"operationId": "AddConfigKeys",
				"parameters": [
					{
						"description": "ConfigID is the ID of the dataset prepare config the user wants to add keys to.",
						"in": "path",
						"name": "config_id",
						"required": true,
						"type": "string"
					},
					{
						"in": "body",
						"name": "body",
						"required": true,
						"schema": {
							"$ref": "#/definitions/Prepare_Configs.AddConfigKeysBody"
						}
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Prepare_Configs.AddConfigKeysResponse"
						}
					},
					"400": {
						"description": "Returned when the AddConfigKey request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"404": {
						"description": "Returned when the dataset prepare config could not be found.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Add a key to a Dataset Prepare Configuration.",
				"tags": [
					"Prepare Configs"
				]
			}
		},
		"/api/v2/datasets": {
			"get": {
				"description": "Returns a list of datasets and their summary information.",
				"operationId": "ListDatasets",
				"parameters": [
					{
						"description": "The requested page of records. Default is 1.",
						"format": "int32",
						"in": "query",
						"name": "pagination.page",
						"required": false,
						"type": "integer"
					},
					{
						"description": "The number of records to return per page. Maximum is 500. Default is 100.",
						"format": "int32",
						"in": "query",
						"name": "pagination.per_page",
						"required": false,
						"type": "integer"
					},
					{
						"description": "OrderBy is a comma seperated value to define sorting.\ne.g 'name,created_time DESC'\nThe values are seperated by space, '{column} {ASC/DESC}'\nThe values that are sortable are:\ndataset_id\npublic_name\nprivate_id\ndescription\nowner_id\ncreated_by\ndataset_type (DATASET_TYPE_INSIGHT / DATASET_TYPE_IDENTITY)\nregion\nrecordset_id\nexecution_id\npublish_date_time (in RFC3339 format)\ncreated_date_time (in RFC3339 format)\nexpiration_date_time (in RFC3339 format)",
						"in": "query",
						"name": "order_by",
						"required": false,
						"type": "string"
					},
					{
						"description": "Filter is a string containing logic that can specify a restricted set of\nCloud Vaults to be returned. e.g. `name co 'Test' or name co 'Acme'`\nThe filterable fields are:\ndataset_id\npublic_name\nprivate_id\ndescription\nowner_id\ncreated_by\ndataset_type (DATASET_TYPE_INSIGHT / DATASET_TYPE_IDENTITY)\nregion\nexecution_id\nrecordset_id\ncreated_date_time (in RFC3339 format)\nexpiration_date_time (in RFC3339 format)\npublish_date_time (in RFC3339 format)",
						"in": "query",
						"name": "filter",
						"required": false,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Datasets.ListDatasetsResponse"
						}
					},
					"400": {
						"description": "Returned when the ListDatasetsRequest message was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Returns a list of datasets and their summary information.",
				"tags": [
					"Datasets"
				]
			},
			"post": {
				"description": "Creates a dataset.",
				"operationId": "CreateDataset",
				"parameters": [
					{
						"description": "CreateDatasetRequest is the input used by the CreateDataset rpc.",
						"in": "body",
						"name": "body",
						"required": true,
						"schema": {
							"$ref": "#/definitions/Datasets.CreateDatasetRequest"
						}
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Datasets.CreateDatasetResponse"
						}
					},
					"400": {
						"description": "Returned when the CreateDatasetRequest message was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Creates a dataset.",
				"tags": [
					"Datasets"
				]
			}
		},
		"/api/v2/datasets/stats/attribute_columns/{dataset_id}": {
			"get": {
				"description": "Get stats for all the attribute columns of a dataset.",
				"operationId": "AttributeColumnStats",
				"parameters": [
					{
						"in": "path",
						"name": "dataset_id",
						"required": true,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Dataset_Stats.AttributeColumnStatsResponse"
						}
					},
					"400": {
						"description": "Returned when the AttributeColumnStats request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"404": {
						"description": "Returned when the dataset ID isn't found.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Get stats for all the attribute columns of a dataset.",
				"tags": [
					"Dataset Stats"
				]
			}
		},
		"/api/v2/datasets/stats/export_columns/{dataset_id}": {
			"get": {
				"description": "Get stats for all the export columns of a dataset.",
				"operationId": "ExportColumnStats",
				"parameters": [
					{
						"in": "path",
						"name": "dataset_id",
						"required": true,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Dataset_Stats.ExportColumnStatsResponse"
						}
					},
					"400": {
						"description": "Returned when the ExportColumnStats request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"404": {
						"description": "Returned when the dataset ID isn't found.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Get stats for all the export columns of a dataset.",
				"tags": [
					"Dataset Stats"
				]
			}
		},
		"/api/v2/datasets/stats/key_columns/{dataset_id}": {
			"get": {
				"description": "Get stats for all the key columns of a dataset.",
				"operationId": "KeyColumnStats",
				"parameters": [
					{
						"in": "path",
						"name": "dataset_id",
						"required": true,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Dataset_Stats.KeyColumnStatsResponse"
						}
					},
					"400": {
						"description": "Returned when the KeyColumnStats request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"404": {
						"description": "Returned when the dataset ID isn't found.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Get stats for all the key columns of a dataset.",
				"tags": [
					"Dataset Stats"
				]
			}
		},
		"/api/v2/datasets/stats/summary/{dataset_id}": {
			"get": {
				"description": "Get summary stats for a dataset.",
				"operationId": "SummaryStats",
				"parameters": [
					{
						"in": "path",
						"name": "dataset_id",
						"required": true,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Dataset_Stats.SummaryStatsResponse"
						}
					},
					"400": {
						"description": "Returned when the SummaryStats request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"404": {
						"description": "Returned when the dataset ID isn't found.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Get summary stats for a dataset.",
				"tags": [
					"Dataset Stats"
				]
			}
		},
		"/api/v2/datasets/{dataset_id}": {
			"delete": {
				"description": "Deletes a dataset and any underlying compute resource.",
				"operationId": "DeleteDataset",
				"parameters": [
					{
						"description": "DatasetId is the ID of the dataset to be deleted.",
						"in": "path",
						"name": "dataset_id",
						"required": true,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Datasets.DeleteDatasetResponse"
						}
					},
					"400": {
						"description": "Returned when the DeleteDatasetRequest message was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Deletes a dataset and any underlying compute resource.",
				"tags": [
					"Datasets"
				]
			},
			"get": {
				"description": "Returns a dataset and the summary information.",
				"operationId": "GetDataset",
				"parameters": [
					{
						"description": "DatasetId is the ID of the dataset to be retrived.",
						"in": "path",
						"name": "dataset_id",
						"required": true,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Datasets.GetDatasetResponse"
						}
					},
					"400": {
						"description": "Returned when the GetDatasetsRequest message was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"404": {
						"description": "Returned when the dataset and summary information could not be found",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Returns a dataset and the summary information.",
				"tags": [
					"Datasets"
				]
			},
			"patch": {
				"description": "Updates the top level information about a dataset.",
				"operationId": "UpdateDataset",
				"parameters": [
					{
						"description": "DatasetId is the ID of the dataset to be updated.",
						"in": "path",
						"name": "dataset_id",
						"required": true,
						"type": "string"
					},
					{
						"description": "Dataset contains details of the update which can be partial.",
						"in": "body",
						"name": "dataset",
						"required": true,
						"schema": {
							"$ref": "#/definitions/Datasets.v2.UpdateDataset"
						}
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Datasets.UpdateDatasetResponse"
						}
					},
					"400": {
						"description": "Returned when the UpdateDatasetRequest message was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Updates the top level information about a dataset.",
				"tags": [
					"Datasets"
				]
			}
		},
		"/api/v2/destinations/instances": {
			"get": {
				"description": "Returns a list of Destinations owned by the caller.",
				"operationId": "ListDestinationInstances",
				"parameters": [
					{
						"description": "The requested page of records. Default is 1.",
						"format": "int32",
						"in": "query",
						"name": "pagination.page",
						"required": false,
						"type": "integer"
					},
					{
						"description": "The number of records to return per page. Maximum is 500. Default is 100.",
						"format": "int32",
						"in": "query",
						"name": "pagination.per_page",
						"required": false,
						"type": "integer"
					},
					{
						"description": "Supported order_by fields are id, created_time, name, updated_time, destination_type_id, creator_id",
						"in": "query",
						"name": "order_by",
						"required": false,
						"type": "string"
					},
					{
						"description": "Supported filters are name, owner_id, destination_type_id, outgoing_permission_id, creator_id",
						"in": "query",
						"name": "filter",
						"required": false,
						"type": "string"
					},
					{
						"description": "PermissionableTo is an optional company ID which if set, filters the returned destinations based on the ability\nto attach the instance to a permission sent to that recipient company.",
						"in": "query",
						"name": "permissionable_to",
						"required": false,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Destination_Instances.ListDestinationInstancesResponse"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the right to list Destinations.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "List Destination Instances",
				"tags": [
					"Destination Instances"
				]
			},
			"post": {
				"description": "Accepts a configuration conforming to the JSON-Schema of the Destination type to be created. Returns Destination ID.",
				"operationId": "CreateDestinationInstance",
				"parameters": [
					{
						"description": "CreateDestinationInstanceRequest contains all parameters required to create a Destination instance.",
						"in": "body",
						"name": "body",
						"required": true,
						"schema": {
							"$ref": "#/definitions/Destination_Instances.CreateDestinationInstanceRequest"
						}
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Destination_Instances.CreateDestinationInstanceResponse"
						}
					},
					"400": {
						"description": "Returned when the request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the right to create a Destination instance.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Create Destination Instance",
				"tags": [
					"Destination Instances"
				]
			}
		},
		"/api/v2/destinations/instances/{destination_id}": {
			"delete": {
				"description": "Deletes an owned destination instance.",
				"operationId": "DeleteDestinationInstance",
				"parameters": [
					{
						"description": "Destination instance ID.",
						"in": "path",
						"name": "destination_id",
						"required": true,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Destination_Instances.DeleteDestinationInstanceResponse"
						}
					},
					"400": {
						"description": "Returned when the request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the right to view the Destination instance.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Delete Destination Instance",
				"tags": [
					"Destination Instances"
				]
			},
			"get": {
				"description": "Returns details about an owned Destination Instance.",
				"operationId": "GetDestinationInstance",
				"parameters": [
					{
						"description": "Destination instance ID.",
						"in": "path",
						"name": "destination_id",
						"required": true,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Destination_Instances.GetDestinationInstanceResponse"
						}
					},
					"400": {
						"description": "Returned when the request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the right to view the Destination instance.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"404": {
						"description": "Returned when the Destination instance could not be found.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Get Destination Instance",
				"tags": [
					"Destination Instances"
				]
			},
			"patch": {
				"description": "Update an owned destination instance.",
				"operationId": "UpdateDestinationInstance",
				"parameters": [
					{
						"description": "destination_id is the ID of the Destination instance.",
						"in": "path",
						"name": "destination_id",
						"required": true,
						"type": "string"
					},
					{
						"description": "DestinationInstanceUpdate is the update to the Destination instance configuration.",
						"in": "body",
						"name": "destination",
						"required": true,
						"schema": {
							"$ref": "#/definitions/Destination_Instances.DestinationInstanceUpdate",
							"description": "Destination instance details."
						}
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Destination_Instances.UpdateDestinationInstanceResponse"
						}
					},
					"400": {
						"description": "Returned when the request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the right to update the Destination instance.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"404": {
						"description": "Returned when the Destination instance could not be found.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Update Destination Instance",
				"tags": [
					"Destination Instances"
				]
			}
		},
		"/api/v2/destinations/instances/{destination_id}/attach": {
			"post": {
				"description": "Attach the specified Destination Instance to the given Permission. The destination must be either owned by, or shared with your company.",
				"operationId": "AttachToPermission",
				"parameters": [
					{
						"description": "Destination Instance ID to attach.",
						"in": "path",
						"name": "destination_id",
						"required": true,
						"type": "string"
					},
					{
						"in": "body",
						"name": "body",
						"required": true,
						"schema": {
							"$ref": "#/definitions/Destination_Instances.AttachToPermissionBody"
						}
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Destination_Instances.AttachToPermissionResponse"
						}
					},
					"400": {
						"description": "Returned when the request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the right to attach a Destination Instance",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"404": {
						"description": "Returned when the Permission ID cannot be found.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Attach Destination Instance to Permission",
				"tags": [
					"Destination Instances"
				]
			}
		},
		"/api/v2/destinations/instances/{destination_id}/detach": {
			"post": {
				"description": "Removes the link between the specified Destination Instance and the given Permission. The destination must be either owned by, or shared with your company.",
				"operationId": "DetachFromPermission",
				"parameters": [
					{
						"description": "Destination Instance ID to detach.",
						"in": "path",
						"name": "destination_id",
						"required": true,
						"type": "string"
					},
					{
						"in": "body",
						"name": "body",
						"required": true,
						"schema": {
							"$ref": "#/definitions/Destination_Instances.DetachFromPermissionBody"
						}
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Destination_Instances.DetachFromPermissionResponse"
						}
					},
					"400": {
						"description": "Returned when the request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the right to detach the Destination Instance from a Permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Detach Destination Instance from Permission",
				"tags": [
					"Destination Instances"
				]
			}
		},
		"/api/v2/destinations/instances/{destination_id}/duplicate": {
			"post": {
				"description": "Creates a new copy of the specified, owned destination instance.Returns Destination ID.",
				"operationId": "DuplicateDestinationInstance",
				"parameters": [
					{
						"description": "Destination Instance ID to duplicate.",
						"in": "path",
						"name": "destination_id",
						"required": true,
						"type": "string"
					},
					{
						"in": "body",
						"name": "body",
						"required": true,
						"schema": {
							"$ref": "#/definitions/Destination_Instances.DuplicateDestinationInstanceBody"
						}
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Destination_Instances.DuplicateDestinationInstanceResponse"
						}
					},
					"400": {
						"description": "Returned when the request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the right to create a Destination instance.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"404": {
						"description": "Returned when the Destination instance could not be found.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Duplicate Destination Instance",
				"tags": [
					"Destination Instances"
				]
			}
		},
		"/api/v2/destinations/shares": {
			"get": {
				"description": "Returns a list of Destinations shared by or with the company of the user.",
				"operationId": "ListDestinationShares",
				"parameters": [
					{
						"description": "The requested page of records. Default is 1.",
						"format": "int32",
						"in": "query",
						"name": "pagination.page",
						"required": false,
						"type": "integer"
					},
					{
						"description": "The number of records to return per page. Maximum is 500. Default is 100.",
						"format": "int32",
						"in": "query",
						"name": "pagination.per_page",
						"required": false,
						"type": "integer"
					},
					{
						"description": "OrderBy is a comma seperated value to define sorting.\ne.g 'created_time,name DESC'\nThe values are seperated by space, '{column} {ASC/DESC}'\nValid columns: name, created_time",
						"in": "query",
						"name": "order_by",
						"required": false,
						"type": "string"
					},
					{
						"description": "Supported filters are `owner_id`, `recipient_company_id`, `destination_id`",
						"in": "query",
						"name": "filter",
						"required": false,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Destination_Shares.ListDestinationSharesResponse"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the right to list Shared Destinations.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "List Destination Shares",
				"tags": [
					"Destination Shares"
				]
			},
			"post": {
				"description": "Accepts a Destination Instance ID and email to share the Destination Instance with. Sharing a Destination allows the recipient to attach it on a dataset permission back to you.",
				"operationId": "CreateDestinationShare",
				"parameters": [
					{
						"in": "body",
						"name": "body",
						"required": true,
						"schema": {
							"$ref": "#/definitions/Destination_Shares.CreateDestinationShareRequest"
						}
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Destination_Shares.CreateDestinationShareResponse"
						}
					},
					"400": {
						"description": "Returned when the request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the right to share a Destination Instance",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"404": {
						"description": "Returned when the Destination Instance ID cannot be found.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Create Destination Share",
				"tags": [
					"Destination Shares"
				]
			}
		},
		"/api/v2/destinations/shares/{share_id}": {
			"delete": {
				"description": "Stops sharing a Destination to a single company.",
				"operationId": "RemoveDestinationShare",
				"parameters": [
					{
						"description": "ID of the Share that should be removed.",
						"in": "path",
						"name": "share_id",
						"required": true,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Destination_Shares.RemoveDestinationShareResponse"
						}
					},
					"400": {
						"description": "Returned when the request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the right to stop sharing a Destination.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Remove Destination Share",
				"tags": [
					"Destination Shares"
				]
			},
			"get": {
				"description": "Returns the shared destination for a specific share ID.",
				"operationId": "GetDestinationShare",
				"parameters": [
					{
						"description": "The ID of the Destination Share to get details about.",
						"in": "path",
						"name": "share_id",
						"required": true,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Destination_Shares.GetDestinationShareResponse"
						}
					},
					"400": {
						"description": "Returned when the request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the right to view details of the sharing of a Destination Instance.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"404": {
						"description": "Returned when the Destination Instance Share could not be found.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Get Destination Share",
				"tags": [
					"Destination Shares"
				]
			}
		},
		"/api/v2/destinations/types": {
			"get": {
				"description": "Returns a list of supported Destination types available to the user. Returned Destination type IDs can be used to fetch the schema and create a destination.",
				"operationId": "ListDestinationTypes",
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Destination_Instances.ListDestinationTypesResponse"
						}
					},
					"400": {
						"description": "Returned when the request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the right to access this endpoint.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "List Destination types",
				"tags": [
					"Destination Instances"
				]
			}
		},
		"/api/v2/destinations/types/{destination_type_id}/external-config": {
			"get": {
				"description": "Returns details required when configuring the third-party service to receive data for this Destination type. Returns empty if the Destination type doesn't require any configuration related to the InfoSum user.",
				"operationId": "GetDestinationTypeExternalConfig",
				"parameters": [
					{
						"description": "Destination type identifier.",
						"in": "path",
						"name": "destination_type_id",
						"required": true,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Destination_Instances.GetDestinationTypeExternalConfigResponse"
						}
					},
					"400": {
						"description": "Returned when the request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the right to access the endpoint.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"404": {
						"description": "Returned when the Destination type could not be found.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Get Destination Type External Config",
				"tags": [
					"Destination Instances"
				]
			}
		},
		"/api/v2/destinations/types/{destination_type_id}/schema": {
			"get": {
				"description": "Returns the configuration [JSON-Schema](https://json-schema.org) for the requested Destination type ID. The JSON-Schema can be used to define a configuration for creating a Destination.",
				"operationId": "GetDestinationTypeSchema",
				"parameters": [
					{
						"description": "Destination type identifier.",
						"in": "path",
						"name": "destination_type_id",
						"required": true,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Destination_Instances.GetDestinationTypeSchemaResponse"
						}
					},
					"400": {
						"description": "Returned when the request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the right to access the endpoint.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"404": {
						"description": "Returned when the Destination type could not be found.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Get Destination Type Schema",
				"tags": [
					"Destination Instances"
				]
			}
		},
		"/api/v2/files/{cloud_vault_id}/{name}": {
			"delete": {
				"description": "Delete the specified file",
				"operationId": "deleteFile",
				"parameters": [
					{
						"description": "The globally unique identifier for the Cloud Vault where the file to delete is.",
						"in": "path",
						"name": "cloud_vault_id",
						"required": true,
						"type": "string"
					},
					{
						"description": "The path of the file to be deleted. If the path ends in '/*' then delete up to 1000 files with that path prefix. Check files_remaining in the response for the status of the prefix.",
						"in": "path",
						"name": "name",
						"pattern": ".+",
						"required": true,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Files.DeleteResponse"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Delete file",
				"tags": [
					"Files"
				]
			}
		},
		"/api/v2/files/{cloud_vault_id}/{path}": {
			"get": {
				"description": "List available files with any metadata",
				"operationId": "listFiles",
				"parameters": [
					{
						"description": "CloudVaultId is the id of the Cloud Vault to list files from.",
						"in": "path",
						"name": "cloud_vault_id",
						"required": true,
						"type": "string"
					},
					{
						"description": "Path is the path within the cloud vault which has been requested.\nThis will often be blank (no path = list the entire cloudvault),\nbut could also be the path of a single file or directory.",
						"in": "path",
						"name": "path",
						"pattern": ".+",
						"required": true,
						"type": "string"
					},
					{
						"description": "The requested page of records. Default is 1.",
						"format": "int32",
						"in": "query",
						"name": "pagination.page",
						"required": false,
						"type": "integer"
					},
					{
						"description": "The number of records to return per page. Maximum is 500. Default is 100.",
						"format": "int32",
						"in": "query",
						"name": "pagination.per_page",
						"required": false,
						"type": "integer"
					},
					{
						"description": "OrderBy is a comma separated value to define sorting.\ne.g 'name,created_time DESC'.\nThe values are separated by space, '{column} {ASC/DESC}'.\nThese are the values that are sortable:\n  name\n  size\n  created_date_time (in RFC3339 format)\n  metadata.updated_date_time (in RFC3339 format)\n  metadata.origin.task_id\n  metadata.origin.task_type\n  metadata.origin.properties",
						"in": "query",
						"name": "order_by",
						"required": false,
						"type": "string"
					},
					{
						"description": "Filter is a string containing logic that can specify a restricted set of\nFiles to be returned. e.g. `name co 'Test' or name co 'Acme'`. These are\nthe supported fields for filtering:\n\nname\n  size\n  created_date_time                           (in RFC3339 format)\n  metadata.origin.task_type\n  metadata.origin.task_id\n  metadata.updated_date_time                  (in RFC3339 format)\n  metadata.resource_type\n  metadata.origin.properties.{property_name}  (dynamic filtering based on the properties)",
						"in": "query",
						"name": "filter",
						"required": false,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Files.ListResponse"
						}
					},
					"400": {
						"description": "Returned when the request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "List files",
				"tags": [
					"Files"
				]
			}
		},
		"/api/v2/imports/connector-configs": {
			"get": {
				"description": "List Import Connector Configs belonging to your company subject to the provided filter.",
				"operationId": "ListImportConnectors",
				"parameters": [
					{
						"description": "The requested page of records. Default is 1.",
						"format": "int32",
						"in": "query",
						"name": "pagination.page",
						"required": false,
						"type": "integer"
					},
					{
						"description": "The number of records to return per page. Maximum is 500. Default is 100.",
						"format": "int32",
						"in": "query",
						"name": "pagination.per_page",
						"required": false,
						"type": "integer"
					},
					{
						"default": "created_date_time DESC",
						"description": "Comma separated list of sorting parameters and ordering in the form of `{sort_column} {ASC/DESC}`. Supported sort fields are: `name`, `connector_type`, `created_date_time`, `updated_date_time`",
						"in": "query",
						"name": "order_by",
						"required": false,
						"type": "string"
					},
					{
						"description": "Filter string as per the [docs](https://infosum.github.io/infosum-docs/docs/v2%20API/filtering). Supported filter fields are: `id`, `name`, `description`, `connector_type`, `created_date_time`, `updated_date_time`.",
						"in": "query",
						"name": "filter",
						"required": false,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Import_Connectors.ListImportConnectorsResponse"
						}
					},
					"400": {
						"description": "Returned when the request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "List Import Connector Configs",
				"tags": [
					"Import Connectors"
				]
			},
			"post": {
				"description": "Creates and validates an Import Connector Config based on the provided connector details.",
				"operationId": "CreateImportConnector",
				"parameters": [
					{
						"description": "The input to the CreateImportConnector method.",
						"in": "body",
						"name": "body",
						"required": true,
						"schema": {
							"$ref": "#/definitions/Import_Connectors.CreateImportConnectorRequest"
						}
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Import_Connectors.CreateImportConnectorResponse"
						}
					},
					"400": {
						"description": "Returned when the request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"409": {
						"description": "Returned when an Import Connector Config with the same name already exists.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Create Import Connector Config",
				"tags": [
					"Import Connectors"
				]
			}
		},
		"/api/v2/imports/connector-configs/gpg-keys/{config_id}/refresh": {
			"post": {
				"description": "Refresh ICC GPG Key pair. Users will have to re-encrypt their files with the new public GPG Key.",
				"operationId": "RefreshGPGKeys",
				"parameters": [
					{
						"description": "The ID of the Import Connector Config that you wish to refresh the GPG keys for.",
						"in": "path",
						"name": "config_id",
						"required": true,
						"type": "string"
					},
					{
						"in": "body",
						"name": "body",
						"required": true,
						"schema": {
							"$ref": "#/definitions/Import_Connectors.RefreshGPGKeysBody"
						}
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Import_Connectors.RefreshGPGKeysResponse"
						}
					},
					"400": {
						"description": "Returned when the request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Refresh the ICC GPG Keys",
				"tags": [
					"Import Connectors"
				]
			}
		},
		"/api/v2/imports/connector-configs/host-key/{host}/{port}": {
			"get": {
				"description": "Returns the first valid public sFTP server host key found. Supported key algorithms are ECDSA, RSA and ED25519.",
				"operationId": "GetHostKey",
				"parameters": [
					{
						"description": "The hostname or IP address of the server to get public keys from.",
						"in": "path",
						"name": "host",
						"required": true,
						"type": "string"
					},
					{
						"description": "The port to acess the server on. For example 22.",
						"format": "int32",
						"in": "path",
						"name": "port",
						"required": true,
						"type": "integer"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Import_Connectors.GetHostKeyResponse"
						}
					},
					"400": {
						"description": "Returned when the request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Get server host key.",
				"tags": [
					"Import Connectors"
				]
			}
		},
		"/api/v2/imports/connector-configs/{config.id}": {
			"patch": {
				"description": "Updates the specified Import Connector Config, overriding any old fields with new ones provided on the request.",
				"operationId": "UpdateImportConnector",
				"parameters": [
					{
						"description": "The unique ID of the Import Connector Config.",
						"in": "path",
						"name": "config.id",
						"required": true,
						"type": "string"
					},
					{
						"in": "body",
						"name": "config",
						"required": true,
						"schema": {
							"description": "UpsertImportConnector is the entity that contains the information to define an Import Connector Config.",
							"properties": {
								"description": {
									"description": "An optional description given to this Import Connector Config.",
									"type": "string"
								},
								"gcs_connector": {
									"allOf": [
										{
											"$ref": "#/definitions/Import_Connectors.GCSConnector"
										}
									],
									"description": "Google Cloud Storage specific information."
								},
								"gpg_key_expiration": {
									"allOf": [
										{
											"$ref": "#/definitions/Import_Connectors.GPGExpiration"
										}
									],
									"description": "Details about the expiration for the GPG key associated with the Import Connector Config."
								},
								"is_gpg": {
									"description": "Enables importing of GPG encrypted files.",
									"type": "boolean"
								},
								"name": {
									"description": "The display name given to the Import Connector Config.",
									"type": "string"
								},
								"s3_connector": {
									"allOf": [
										{
											"$ref": "#/definitions/Import_Connectors.S3Connector"
										}
									],
									"description": "AWS S3 specific information."
								},
								"sftp_connector": {
									"allOf": [
										{
											"$ref": "#/definitions/Import_Connectors.SFTPConnector"
										}
									],
									"description": "SFTP server specific information."
								}
							},
							"type": "object"
						}
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Import_Connectors.UpdateImportConnectorResponse"
						}
					},
					"400": {
						"description": "Returned when the request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"404": {
						"description": "Returned when the Import Connector Config could not be found.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Update Import Connector Config",
				"tags": [
					"Import Connectors"
				]
			}
		},
		"/api/v2/imports/connector-configs/{config_id}": {
			"delete": {
				"description": "Remove the specified Import Connector Config. Import Connector Configs can only be removed if they are not in use by an Importer.",
				"operationId": "DeleteImportConnector",
				"parameters": [
					{
						"description": "The ID of the Import Connector Config to be deleted.",
						"in": "path",
						"name": "config_id",
						"required": true,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Import_Connectors.DeleteImportConnectorResponse"
						}
					},
					"400": {
						"description": "Returned when the request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Delete Import Connector Config",
				"tags": [
					"Import Connectors"
				]
			},
			"get": {
				"description": "Fetches an Import Connector Config by its Config ID.",
				"operationId": "GetImportConnector",
				"parameters": [
					{
						"description": "The ID of the Import Connector Config to retrieve.",
						"in": "path",
						"name": "config_id",
						"required": true,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Import_Connectors.GetImportConnectorResponse"
						}
					},
					"400": {
						"description": "Returned when the request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"404": {
						"description": "Returned when the Import Connector Config could not be found.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Get Import Connector Config",
				"tags": [
					"Import Connectors"
				]
			}
		},
		"/api/v2/imports/executions": {
			"get": {
				"description": "List all import executions.",
				"operationId": "ListImportExecutions",
				"parameters": [
					{
						"description": "The requested page of records. Default is 1.",
						"format": "int32",
						"in": "query",
						"name": "pagination.page",
						"required": false,
						"type": "integer"
					},
					{
						"description": "The number of records to return per page. Maximum is 500. Default is 100.",
						"format": "int32",
						"in": "query",
						"name": "pagination.per_page",
						"required": false,
						"type": "integer"
					},
					{
						"description": "A comma seperated value to define sorting e.g 'current_status DESC' The values are seperated by space, '{column} {ASC/DESC}'",
						"in": "query",
						"name": "order_by",
						"required": false,
						"type": "string"
					},
					{
						"description": "A string containing logic that can specify a restricted set of Executions to be returned. e.g. `current_status eq 'WAITING'`",
						"in": "query",
						"name": "filter",
						"required": false,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Import_Executions.ListImportExecutionsResponse"
						}
					},
					"400": {
						"description": "Returned when the request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "List Import Executions",
				"tags": [
					"Import Executions"
				]
			}
		},
		"/api/v2/imports/executions/{execution_id}": {
			"get": {
				"description": "Gets a specific import execution.",
				"operationId": "GetImportExecution",
				"parameters": [
					{
						"description": "The ID of the Import execution task to retrieve.",
						"in": "path",
						"name": "execution_id",
						"required": true,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Import_Executions.GetImportExecutionResponse"
						}
					},
					"400": {
						"description": "Returned when the request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"404": {
						"description": "Returned when the Execution could not be found.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Gets Import Execution",
				"tags": [
					"Import Executions"
				]
			}
		},
		"/api/v2/imports/executions/{execution_id}/cancel": {
			"post": {
				"description": "Cancels a specific import execution.",
				"operationId": "CancelImportExecution",
				"parameters": [
					{
						"description": "The ID of the Import execution task to cancel.",
						"in": "path",
						"name": "execution_id",
						"required": true,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Import_Executions.CancelImportExecutionResponse"
						}
					},
					"400": {
						"description": "Returned when the request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"404": {
						"description": "Returned when the Execution could not be found.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Cancel Import Execution",
				"tags": [
					"Import Executions"
				]
			}
		},
		"/api/v2/imports/importers": {
			"get": {
				"description": "List available Imports.",
				"operationId": "ListImports",
				"parameters": [
					{
						"description": "The requested page of records. Default is 1.",
						"format": "int32",
						"in": "query",
						"name": "pagination.page",
						"required": false,
						"type": "integer"
					},
					{
						"description": "The number of records to return per page. Maximum is 500. Default is 100.",
						"format": "int32",
						"in": "query",
						"name": "pagination.per_page",
						"required": false,
						"type": "integer"
					},
					{
						"description": "A comma seperated value to define sorting e.g 'name,created_time DESC' The values are seperated by space, '{column} {ASC/DESC}'",
						"in": "query",
						"name": "order_by",
						"required": false,
						"type": "string"
					},
					{
						"description": "A string containing logic that can specify a restricted set of Importers to be returned e.g. `name co 'Test' or name co 'Acme'`",
						"in": "query",
						"name": "filter",
						"required": false,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Importers.ListImportsResponse"
						}
					},
					"400": {
						"description": "Returned when the request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "List Importers",
				"tags": [
					"Importers"
				]
			},
			"post": {
				"description": "Create a configuration for importing data.",
				"operationId": "CreateImport",
				"parameters": [
					{
						"description": "The input to the CreateImport method.",
						"in": "body",
						"name": "body",
						"required": true,
						"schema": {
							"$ref": "#/definitions/Importers.CreateImportRequest"
						}
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Importers.CreateImportResponse"
						}
					},
					"400": {
						"description": "Returned when the request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"409": {
						"description": "Returned when an Import with the same name already exists.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Create Importer",
				"tags": [
					"Importers"
				]
			}
		},
		"/api/v2/imports/importers/{import.id}": {
			"patch": {
				"description": "Updates the provided fields in a specific Import.",
				"operationId": "UpdateImport",
				"parameters": [
					{
						"description": "The globally unique ID of the import.",
						"in": "path",
						"name": "import.id",
						"required": true,
						"type": "string"
					},
					{
						"in": "body",
						"name": "import",
						"required": true,
						"schema": {
							"description": "The information required to define an import.",
							"properties": {
								"cloud_vault_id": {
									"description": "The identifier for the Cloud Vault to where the files will be imported.",
									"type": "string"
								},
								"created_date_time": {
									"description": "The date and time the import was created.",
									"format": "date-time",
									"readOnly": true,
									"type": "string"
								},
								"data_filter": {
									"allOf": [
										{
											"$ref": "#/definitions/Importers.DataFilter"
										}
									],
									"description": "The filtered data to import from the import connector."
								},
								"description": {
									"description": "A description for the import.",
									"type": "string"
								},
								"icc_id": {
									"description": "The id of the import connector config used by the import.",
									"type": "string"
								},
								"name": {
									"description": "The name given to the import.",
									"type": "string"
								},
								"owner_id": {
									"type": "string"
								},
								"target_folder": {
									"description": "The target folder for the import. This field can be a path containing subfolders. Valid characters are alphanumeric, '_', '-', '.', '/'. This field cannot start or end with a '/'. The 'Recordsets' folder cannot be imported into. This field will be mandatory in the near future.",
									"type": "string"
								},
								"updated_date_time": {
									"description": "The date and time the import was last updated.",
									"format": "date-time",
									"readOnly": true,
									"type": "string"
								},
								"user_id": {
									"description": "The id of the user who created the import.",
									"readOnly": true,
									"type": "string"
								}
							},
							"type": "object"
						}
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Importers.UpdateImportResponse"
						}
					},
					"400": {
						"description": "Returned when the request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"404": {
						"description": "Returned when the Import could not be found.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Update Importer",
				"tags": [
					"Importers"
				]
			}
		},
		"/api/v2/imports/importers/{import_id}": {
			"delete": {
				"description": "Deletes a specific Import.",
				"operationId": "DeleteImport",
				"parameters": [
					{
						"description": "The ID of the Import to delete.",
						"in": "path",
						"name": "import_id",
						"required": true,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Importers.DeleteImportResponse"
						}
					},
					"400": {
						"description": "Returned when the request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Delete Importer",
				"tags": [
					"Importers"
				]
			},
			"get": {
				"description": "Get the details of a specific Import.",
				"operationId": "GetImport",
				"parameters": [
					{
						"description": "The ID of the Import to retrieve.",
						"in": "path",
						"name": "import_id",
						"required": true,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Importers.GetImportResponse"
						}
					},
					"400": {
						"description": "Returned when the request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"404": {
						"description": "Returned when the Import could not be found.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Get Importer",
				"tags": [
					"Importers"
				]
			}
		},
		"/api/v2/imports/importers/{import_id}/execute": {
			"post": {
				"description": "Executes an import for the specified import ID.",
				"operationId": "ExecuteImport",
				"parameters": [
					{
						"description": "The ID of the Import to execute.",
						"in": "path",
						"name": "import_id",
						"required": true,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Import_Executions.ExecuteImportResponse"
						}
					},
					"400": {
						"description": "Returned when the request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"404": {
						"description": "Returned when the Importer could not be found.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Execute Import",
				"tags": [
					"Import Executions"
				]
			}
		},
		"/api/v2/imports/uploads": {
			"get": {
				"description": "List all local file uploads.",
				"operationId": "List",
				"parameters": [
					{
						"description": "The requested page of records. Default is 1.",
						"format": "int32",
						"in": "query",
						"name": "pagination.page",
						"required": false,
						"type": "integer"
					},
					{
						"description": "The number of records to return per page. Maximum is 500. Default is 100.",
						"format": "int32",
						"in": "query",
						"name": "pagination.per_page",
						"required": false,
						"type": "integer"
					},
					{
						"description": "A comma separated value to define sorting e.g 'current_status DESC'. The values are seperated by a space: '{column} {ASC/DESC}'.",
						"in": "query",
						"name": "order_by",
						"required": false,
						"type": "string"
					},
					{
						"description": "A string containing logic that can specify a restricted set of local file uploads to be returned.",
						"in": "query",
						"name": "filter",
						"required": false,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Imports.ListResponse"
						}
					},
					"400": {
						"description": "Returned when the request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "List local file uploads",
				"tags": [
					"Imports"
				]
			},
			"post": {
				"description": "Creates a local upload for the specified file path in a Cloud Vault.",
				"operationId": "Create",
				"parameters": [
					{
						"description": "The request body to create a new local file upload.",
						"in": "body",
						"name": "body",
						"required": true,
						"schema": {
							"$ref": "#/definitions/Imports.CreateRequest"
						}
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Imports.CreateResponse"
						}
					},
					"400": {
						"description": "Returned when the request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"404": {
						"description": "Returned when the Cloud Vault is not found.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Create a local file upload",
				"tags": [
					"Imports"
				]
			}
		},
		"/api/v2/imports/uploads/{local_file_upload_id}": {
			"get": {
				"description": "Gets information for a single local file upload.",
				"operationId": "Get",
				"parameters": [
					{
						"description": "The ID of the local file upload task to retrieve.",
						"in": "path",
						"name": "local_file_upload_id",
						"required": true,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Imports.GetResponse"
						}
					},
					"400": {
						"description": "Returned when the request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"404": {
						"description": "Returned when the local file upload is not found.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Get a local file upload",
				"tags": [
					"Imports"
				]
			}
		},
		"/api/v2/imports/uploads/{local_file_upload_id}/cancel": {
			"post": {
				"description": "Cancels a local file upload.",
				"operationId": "Cancel",
				"parameters": [
					{
						"description": "The ID of the local file upload task to cancel.",
						"in": "path",
						"name": "local_file_upload_id",
						"required": true,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Imports.CancelResponse"
						}
					},
					"400": {
						"description": "Returned when the local file upload is not in a cancellable state.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"404": {
						"description": "Returned when the local file upload is not found.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Cancel a local file upload",
				"tags": [
					"Imports"
				]
			}
		},
		"/api/v2/lineage/publish/{dataset_id}": {
			"get": {
				"description": "Get all the configs used to publish a dataset",
				"operationId": "GetPublish",
				"parameters": [
					{
						"description": "The ID of the published dataset to get lineage for.",
						"in": "path",
						"name": "dataset_id",
						"required": true,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Dataset_Lineage.GetPublishResponse"
						}
					},
					"400": {
						"description": "Returned when the request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"404": {
						"description": "Returned when the dataset could not be found.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Get the lineage of a published dataset",
				"tags": [
					"Dataset Lineage"
				]
			}
		},
		"/api/v2/normalizations/configs": {
			"get": {
				"description": "List company normalization configurations",
				"operationId": "ListConfigs",
				"parameters": [
					{
						"description": "The requested page of records. Default is 1.",
						"format": "int32",
						"in": "query",
						"name": "pagination.page",
						"required": false,
						"type": "integer"
					},
					{
						"description": "The number of records to return per page. Maximum is 500. Default is 100.",
						"format": "int32",
						"in": "query",
						"name": "pagination.per_page",
						"required": false,
						"type": "integer"
					},
					{
						"description": "OrderBy is a comma seperated value to define sorting.\ne.g 'name,created_time DESC'\nThe values are seperated by space, '{column} {ASC/DESC}'\n\nThe following values are permitted:\n    name\n    created_date_time (RFC3339 format)\n    updated_date_time (RFC3339 format)",
						"in": "query",
						"name": "order_by",
						"required": false,
						"type": "string"
					},
					{
						"description": "Filter is a string containing logic that can specify a restricted set of\nCloud Vaults to be returned. e.g. `name co 'Test' or name co 'Acme'`\n\nThe following values are permitted:\n    name\n    created_date_time (RFC3339 format)\n    updated_date_time (RFC3339 format)",
						"in": "query",
						"name": "filter",
						"required": false,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Normalization_Config.ListConfigsResponse"
						}
					},
					"400": {
						"description": "Returned when the ListConfigs request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "List company Normalization Configurations.",
				"tags": [
					"Normalization Config"
				]
			},
			"post": {
				"description": "Creates a normalization config",
				"operationId": "CreateConfig",
				"parameters": [
					{
						"in": "body",
						"name": "body",
						"required": true,
						"schema": {
							"$ref": "#/definitions/Normalization_Config.CreateConfigRequest"
						}
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Normalization_Config.CreateConfigResponse"
						}
					},
					"400": {
						"description": "Returned when the CreateConfigRequest request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Creates a normalization config.",
				"tags": [
					"Normalization Config"
				]
			}
		},
		"/api/v2/normalizations/configs/{config_id}": {
			"delete": {
				"description": "Delete a normalization config",
				"operationId": "DeleteConfig",
				"parameters": [
					{
						"description": "NormalizationConfigID is the ID of the Normalization Configuration the user wants to delete.",
						"in": "path",
						"name": "config_id",
						"required": true,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Normalization_Config.DeleteConfigResponse"
						}
					},
					"400": {
						"description": "Returned when the DeleteConfig request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Delete a Normalization Config.",
				"tags": [
					"Normalization Config"
				]
			},
			"get": {
				"description": "Get a normalization configuration",
				"operationId": "GetConfig",
				"parameters": [
					{
						"description": "ConfigID is the ID of the Normalization Configuration the user wants to get.",
						"in": "path",
						"name": "config_id",
						"required": true,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Normalization_Config.GetConfigResponse"
						}
					},
					"400": {
						"description": "Returned when the GetConfig request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"404": {
						"description": "Returned when the normalization config could not be found.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Get a Normalization Configuration.",
				"tags": [
					"Normalization Config"
				]
			}
		},
		"/api/v2/normalizations/execute": {
			"post": {
				"description": "Start a normalization",
				"operationId": "Normalize",
				"parameters": [
					{
						"description": "NormalizeRequest is used to start a normalization.",
						"in": "body",
						"name": "body",
						"required": true,
						"schema": {
							"$ref": "#/definitions/Normalizations.NormalizeRequest"
						}
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Normalizations.NormalizeResponse"
						}
					},
					"400": {
						"description": "Returned when the Normalize request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"409": {
						"description": "Returned when an Normalize request with the same prefix already exists.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Start a Normalization.",
				"tags": [
					"Normalizations"
				]
			}
		},
		"/api/v2/normalizations/executions": {
			"get": {
				"description": "List company normalizations",
				"operationId": "ListNormalizations",
				"parameters": [
					{
						"description": "The requested page of records. Default is 1.",
						"format": "int32",
						"in": "query",
						"name": "pagination.page",
						"required": false,
						"type": "integer"
					},
					{
						"description": "The number of records to return per page. Maximum is 500. Default is 100.",
						"format": "int32",
						"in": "query",
						"name": "pagination.per_page",
						"required": false,
						"type": "integer"
					},
					{
						"description": "OrderBy is the ordering for returned transform executions.",
						"in": "query",
						"name": "order_by",
						"required": false,
						"type": "string"
					},
					{
						"description": "Filter is a string containing logic that can specify a restricted set of Transforms to be returned.\ne.g. `history.status co \"READY\"`.",
						"in": "query",
						"name": "filter",
						"required": false,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Normalizations.ListNormalizationsResponse"
						}
					},
					"400": {
						"description": "Returned when the ListNormalizations request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "List company Normalizations.",
				"tags": [
					"Normalizations"
				]
			}
		},
		"/api/v2/normalizations/executions/{execution_id}": {
			"get": {
				"description": "Get a normalization",
				"operationId": "GetNormalization",
				"parameters": [
					{
						"description": "NormalizationID is the ID of the normalization.",
						"in": "path",
						"name": "execution_id",
						"required": true,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Normalizations.GetNormalizationResponse"
						}
					},
					"400": {
						"description": "Returned when the GetNormalization request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"404": {
						"description": "Returned when the Normalization ID isn't found.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Get a Normalization.",
				"tags": [
					"Normalizations"
				]
			}
		},
		"/api/v2/normalizations/executions/{execution_id}/cancel": {
			"post": {
				"description": "Cancel a normalization",
				"operationId": "CancelNormalization",
				"parameters": [
					{
						"description": "NormalizationID is the ID of the normalization.",
						"in": "path",
						"name": "execution_id",
						"required": true,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Normalizations.CancelNormalizationResponse"
						}
					},
					"400": {
						"description": "Returned when the CancelNormalization request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"404": {
						"description": "Returned when the Normalize ID isn't found.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Cancel a Normalize.",
				"tags": [
					"Normalizations"
				]
			}
		},
		"/api/v2/normalizations/global-schema/categories": {
			"get": {
				"description": "List global schema categories",
				"operationId": "Categories",
				"parameters": [
					{
						"description": "The requested page of records. Default is 1.",
						"format": "int32",
						"in": "query",
						"name": "pagination.page",
						"required": false,
						"type": "integer"
					},
					{
						"description": "The number of records to return per page. Maximum is 500. Default is 100.",
						"format": "int32",
						"in": "query",
						"name": "pagination.per_page",
						"required": false,
						"type": "integer"
					},
					{
						"description": "OrderBy is a comma seperated value to define sorting.\ne.g 'name,created_time DESC'\nThe values are seperated by space, '{column} {ASC/DESC}'\n\nThe following values are permitted:\n    name",
						"in": "query",
						"name": "order_by",
						"required": false,
						"type": "string"
					},
					{
						"description": "Filter is a string containing logic that can specify a restricted set of\nCloud Vaults to be returned. e.g. `name co 'Test' or name co 'Acme'`\n\nThe following values are permitted:\n    name",
						"in": "query",
						"name": "filter",
						"required": false,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Global_Schema.CategoriesResponse"
						}
					},
					"400": {
						"description": "Returned when the Categories request is invalid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "List Global Schema Categories.",
				"tags": [
					"Global Schema"
				]
			}
		},
		"/api/v2/normalizations/global-schema/keys": {
			"get": {
				"description": "List global schema keys",
				"operationId": "Keys",
				"parameters": [
					{
						"description": "The requested page of records. Default is 1.",
						"format": "int32",
						"in": "query",
						"name": "pagination.page",
						"required": false,
						"type": "integer"
					},
					{
						"description": "The number of records to return per page. Maximum is 500. Default is 100.",
						"format": "int32",
						"in": "query",
						"name": "pagination.per_page",
						"required": false,
						"type": "integer"
					},
					{
						"description": "OrderBy is a comma seperated value to define sorting.\ne.g 'name,created_time DESC'\nThe values are seperated by space, '{column} {ASC/DESC}'\n\nThe following values are permitted:\n    name",
						"in": "query",
						"name": "order_by",
						"required": false,
						"type": "string"
					},
					{
						"description": "Filter is a string containing logic that can specify a restricted set of\nCloud Vaults to be returned. e.g. `name co 'Test' or name co 'Acme'`\n\nThe following values are permitted:\n    name",
						"in": "query",
						"name": "filter",
						"required": false,
						"type": "string"
					},
					{
						"collectionFormat": "multi",
						"description": "CategoryIds is the list of Category IDs that are available in the current Category assignment\nand specifies what keys should be returned.",
						"in": "query",
						"items": {
							"format": "int64",
							"type": "string"
						},
						"name": "category_ids",
						"required": false,
						"type": "array"
					},
					{
						"collectionFormat": "multi",
						"description": "Type describes the data type assigned to a given category.\n\n - INT64: INT64 is the signed 64-bit integer type.\n - UINT64: UINT64 is the unsigned 64-bit integer type.\n - DOUBLE: DOUBLE is the floating point type.\n - TEXT: TEXT is the string type.\n - BOOLEAN: BOOLEAN is the boolean type.\n - BYTES: BYTES is the bytes type.\n - INT64RANGE: INT64RANGE is the range of signed 64-bit integers type.\n - TEXTARRAY: TEXTARRAY is the text array type.\n - INT64ARRAY: INT64ARRAY is the int64 array type.",
						"in": "query",
						"items": {
							"enum": [
								"TYPE_INVALID",
								"INT64",
								"UINT64",
								"DOUBLE",
								"TEXT",
								"BOOLEAN",
								"BYTES",
								"INT64RANGE",
								"TEXTARRAY",
								"INT64ARRAY"
							],
							"type": "string"
						},
						"name": "type",
						"required": false,
						"type": "array"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Global_Schema.KeysResponse"
						}
					},
					"400": {
						"description": "Returned when the Keys request is invalid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"404": {
						"description": "Returned when the Keys Category IDs cannot be found.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "List Global Schema Keys.",
				"tags": [
					"Global Schema"
				]
			}
		},
		"/api/v2/normalizations/global-schema/keys/categories": {
			"get": {
				"description": "List global schema key categories",
				"operationId": "KeyCategories",
				"parameters": [
					{
						"description": "The requested page of records. Default is 1.",
						"format": "int32",
						"in": "query",
						"name": "pagination.page",
						"required": false,
						"type": "integer"
					},
					{
						"description": "The number of records to return per page. Maximum is 500. Default is 100.",
						"format": "int32",
						"in": "query",
						"name": "pagination.per_page",
						"required": false,
						"type": "integer"
					},
					{
						"description": "OrderBy is a comma seperated value to define sorting.\ne.g 'name,created_time DESC'\nThe values are seperated by space, '{column} {ASC/DESC}'\n\nThe following values are permitted:\n    name",
						"in": "query",
						"name": "order_by",
						"required": false,
						"type": "string"
					},
					{
						"description": "Filter is a string containing logic that can specify a restricted set of\nCloud Vaults to be returned. e.g. `name co 'Test' or name co 'Acme'`\n\nThe following values are permitted:\n    name",
						"in": "query",
						"name": "filter",
						"required": false,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Global_Schema.KeyCategoriesResponse"
						}
					},
					"400": {
						"description": "Returned when the Key Categories request is invalid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "List Global Schema Key Categories.",
				"tags": [
					"Global Schema"
				]
			}
		},
		"/api/v2/prepares/execute": {
			"post": {
				"description": "Start a Prepare Operation",
				"operationId": "Prepare",
				"parameters": [
					{
						"description": "PrepareRequest is used to prepare a dataset.",
						"in": "body",
						"name": "body",
						"required": true,
						"schema": {
							"$ref": "#/definitions/Publishing.PrepareRequest"
						}
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Publishing.PrepareResponse"
						}
					},
					"400": {
						"description": "Returned when the Prepare request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"409": {
						"description": "Returned when an Prepare request with the same prefix already exists.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Start a Prepare on normalized data.",
				"tags": [
					"Publishing"
				]
			}
		},
		"/api/v2/prepares/executions": {
			"get": {
				"description": "List company prepares",
				"operationId": "ListPrepares",
				"parameters": [
					{
						"description": "The requested page of records. Default is 1.",
						"format": "int32",
						"in": "query",
						"name": "pagination.page",
						"required": false,
						"type": "integer"
					},
					{
						"description": "The number of records to return per page. Maximum is 500. Default is 100.",
						"format": "int32",
						"in": "query",
						"name": "pagination.per_page",
						"required": false,
						"type": "integer"
					},
					{
						"description": "OrderBy is the ordering for returned prepare executions.",
						"in": "query",
						"name": "order_by",
						"required": false,
						"type": "string"
					},
					{
						"description": "Filter is a string containing logic that can specify a restricted set of\nCloud Vaults to be returned. e.g. `name co 'Test' or name co 'Acme'`",
						"in": "query",
						"name": "filter",
						"required": false,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Publishing.ListPreparesResponse"
						}
					},
					"400": {
						"description": "Returned when the ListPrepares request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "List company Prepares.",
				"tags": [
					"Publishing"
				]
			}
		},
		"/api/v2/prepares/executions/{execution_id}": {
			"get": {
				"description": "Get details on a Prepare operation.",
				"operationId": "GetPrepare",
				"parameters": [
					{
						"description": "ExecutionID is the ID of the prepare execution to fetch.",
						"in": "path",
						"name": "execution_id",
						"required": true,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Publishing.GetPrepareResponse"
						}
					},
					"400": {
						"description": "Returned when the GetPrepare request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"404": {
						"description": "Returned when the dataset ID isn't found.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Get details on a Prepare operation.",
				"tags": [
					"Publishing"
				]
			}
		},
		"/api/v2/prepares/executions/{execution_id}/cancel": {
			"post": {
				"description": "Cancel a Prepare operation",
				"operationId": "CancelPrepare",
				"parameters": [
					{
						"description": "ExecutionID is the ID of the prepare execution to cancel.",
						"in": "path",
						"name": "execution_id",
						"required": true,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Publishing.CancelPrepareResponse"
						}
					},
					"400": {
						"description": "Returned when the CancelPrepare request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"404": {
						"description": "Returned when the dataset ID isn't found.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Cancel a Prepare operation.",
				"tags": [
					"Publishing"
				]
			}
		},
		"/api/v2/prepares/executions/{execution_id}/stats": {
			"get": {
				"description": "Get stats about a specific prepare operation.",
				"operationId": "GetPrepareStats",
				"parameters": [
					{
						"description": "ExecutionID is the ID of the prepare execution to fetch stats for.",
						"in": "path",
						"name": "execution_id",
						"required": true,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Publishing.GetPrepareStatsResponse"
						}
					},
					"400": {
						"description": "Returned when the GetPrepareStats request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"404": {
						"description": "Returned when the dataset ID isn't found.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Get stats about a specific prepare operation.",
				"tags": [
					"Publishing"
				]
			}
		},
		"/api/v2/prepares/{execution_id}/publish": {
			"post": {
				"description": "Publishes prepared data to a dataset.",
				"operationId": "Publish",
				"parameters": [
					{
						"description": "ExecutionID is the id of the prepare execution to publish to the dataset.",
						"in": "path",
						"name": "execution_id",
						"required": true,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Publishing.PublishResponse"
						}
					},
					"400": {
						"description": "Returned when the Publish request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Publishes prepared data to a dataset.",
				"tags": [
					"Publishing"
				]
			}
		},
		"/api/v2/queries/pair/activation": {
			"post": {
				"description": "Create a PAIR enabled activation query.",
				"operationId": "CreatePairQuery",
				"parameters": [
					{
						"description": "CreatePairQueryRequest is the input to the CreatePairQuery method.",
						"in": "body",
						"name": "body",
						"required": true,
						"schema": {
							"$ref": "#/definitions/Queries.CreatePairQueryRequest"
						}
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Queries.CreatePairQueryResponse"
						}
					},
					"400": {
						"description": "Returned when the request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Create a PAIR enabled activation query",
				"tags": [
					"Queries"
				]
			}
		},
		"/api/v2/queries/private-path": {
			"post": {
				"description": "Create a new private path collaboration between given datasets",
				"operationId": "CreatePrivatePath",
				"parameters": [
					{
						"description": "CreatePrivatePathRequest is the input to the CreatePrivatePath method.",
						"in": "body",
						"name": "body",
						"required": true,
						"schema": {
							"$ref": "#/definitions/Queries.CreatePrivatePathRequest"
						}
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Queries.CreatePrivatePathResponse"
						}
					},
					"400": {
						"description": "Returned when the request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Create new private path collaboration",
				"tags": [
					"Queries"
				]
			}
		},
		"/api/v2/queries/private-path/{collaboration_id}": {
			"get": {
				"description": "Get details of an existing private path collaboration.",
				"operationId": "GetPrivatePath",
				"parameters": [
					{
						"description": "CollaborationId is the unique ID generated for the private path collaboration.",
						"in": "path",
						"name": "collaboration_id",
						"required": true,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Queries.GetPrivatePathResponse"
						}
					},
					"400": {
						"description": "Returned when the request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Get details of an existing private path collaboration.",
				"tags": [
					"Queries"
				]
			}
		},
		"/api/v2/recordset-configs": {
			"get": {
				"description": "List all recordset configs.",
				"operationId": "ListConfigs",
				"parameters": [
					{
						"description": "The requested page of records. Default is 1.",
						"format": "int32",
						"in": "query",
						"name": "pagination.page",
						"required": false,
						"type": "integer"
					},
					{
						"description": "The number of records to return per page. Maximum is 500. Default is 100.",
						"format": "int32",
						"in": "query",
						"name": "pagination.per_page",
						"required": false,
						"type": "integer"
					},
					{
						"description": "OrderBy is a comma seperated value to define sorting.",
						"in": "query",
						"name": "order_by",
						"required": false,
						"type": "string"
					},
					{
						"description": "Filter is a string containing logic that can specify a restricted set of Configs to be returned.",
						"in": "query",
						"name": "filter",
						"required": false,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Recordset_Configs.ListConfigsResponse"
						}
					},
					"400": {
						"description": "Returned when the request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"404": {
						"description": "Returned when a resource is not found.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "List Recordset Configs.",
				"tags": [
					"Recordset Configs"
				]
			},
			"post": {
				"description": "Create a recordset Config that can be used to create a Recordset from files on a cloud vault.",
				"operationId": "CreateConfig",
				"parameters": [
					{
						"description": "CreateConfigRequest contains the information required to create a recordset config.",
						"in": "body",
						"name": "body",
						"required": true,
						"schema": {
							"$ref": "#/definitions/Recordset_Configs.CreateConfigRequest"
						}
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Recordset_Configs.CreateConfigResponse"
						}
					},
					"400": {
						"description": "Returned when the request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"404": {
						"description": "Returned when a resource is not found.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"409": {
						"description": "Returned when a config with the same name already exists.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Create a Recordset Config.",
				"tags": [
					"Recordset Configs"
				]
			}
		},
		"/api/v2/recordset-configs/{config.id}": {
			"patch": {
				"description": "Update the details of a specific recordset config.",
				"operationId": "UpdateConfig",
				"parameters": [
					{
						"description": "Output only. id is the config ID.",
						"in": "path",
						"name": "config.id",
						"required": true,
						"type": "string"
					},
					{
						"in": "body",
						"name": "config",
						"required": true,
						"schema": {
							"description": "Config contains information about a recordset config.",
							"properties": {
								"created_by": {
									"description": "Output only. CreatedBy is the id of the user who created the config.",
									"readOnly": true,
									"type": "string"
								},
								"created_date_time": {
									"description": "Output only. CreatedDateTime is the date time of when the config was created.",
									"format": "date-time",
									"readOnly": true,
									"type": "string"
								},
								"description": {
									"description": "Description is an optional description given to this config.",
									"type": "string"
								},
								"file_type": {
									"allOf": [
										{
											"$ref": "#/definitions/Recordset_Configs.FileType"
										}
									],
									"description": "Allows the user to dictate the file format used by the recordset creation task to read the input files, disregarding any file extensions."
								},
								"header_names": {
									"description": "HeaderNames is a list of the header/column names. To be provided if the files do not contain a header row.\nMust be in the same order as the columns in the files.",
									"items": {
										"type": "string"
									},
									"type": "array"
								},
								"header_row": {
									"description": "HeaderRow indicates whether the files have a header row.",
									"type": "boolean"
								},
								"name": {
									"description": "Name is a unique name to help identify the config. Valid characters are alphanumeric, '_', '-', ' '.",
									"type": "string"
								},
								"primary_delimiter": {
									"description": "PrimaryDelimiter is the primary delimiter of the data.",
									"type": "string"
								},
								"secondary_delimiter": {
									"description": "SecondaryDelimiter is the secondary delimiter of the data, if any.",
									"type": "string"
								},
								"updated_date_time": {
									"description": "Output only. UpdatedDateTime is date time of when the config was last updated.",
									"format": "date-time",
									"readOnly": true,
									"type": "string"
								}
							},
							"type": "object"
						}
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Recordset_Configs.UpdateConfigResponse"
						}
					},
					"400": {
						"description": "Returned when the request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"404": {
						"description": "Returned when the recordset config could not be found.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"409": {
						"description": "Returned when a config with the same name already exists.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Update a Recordset Config.",
				"tags": [
					"Recordset Configs"
				]
			}
		},
		"/api/v2/recordset-configs/{config_id}": {
			"delete": {
				"description": "Delete a specific recordset config.",
				"operationId": "DeleteConfig",
				"parameters": [
					{
						"in": "path",
						"name": "config_id",
						"required": true,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Recordset_Configs.DeleteConfigResponse"
						}
					},
					"400": {
						"description": "Returned when the request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"404": {
						"description": "Returned when a resource is not found.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Delete a Recordset Config.",
				"tags": [
					"Recordset Configs"
				]
			},
			"get": {
				"description": "Get the details of a specific recordset config.",
				"operationId": "GetConfig",
				"parameters": [
					{
						"description": "The ID of the config to get.",
						"in": "path",
						"name": "config_id",
						"required": true,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Recordset_Configs.GetConfigResponse"
						}
					},
					"400": {
						"description": "Returned when the request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"404": {
						"description": "Returned when the recordset config could not be found.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Get a Recordset Config.",
				"tags": [
					"Recordset Configs"
				]
			}
		},
		"/api/v2/recordset-creation/execute": {
			"post": {
				"description": "Create a recordset from files on a cloud vault. Valid characters for recordset names: alphanumeric, '_', '-', ' '.",
				"operationId": "CreateExecution",
				"parameters": [
					{
						"description": "CreateExecutionRequest contains the information required to create a recordset.",
						"in": "body",
						"name": "body",
						"required": true,
						"schema": {
							"$ref": "#/definitions/Recordset_Creation.CreateExecutionRequest"
						}
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Recordset_Creation.CreateExecutionResponse"
						}
					},
					"400": {
						"description": "Returned when the request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"404": {
						"description": "Returned when a resource is not found.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"409": {
						"description": "Returned when a recordset with the same name already exists.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Create a Recordset.",
				"tags": [
					"Recordset Creation"
				]
			}
		},
		"/api/v2/recordset-creation/executions": {
			"get": {
				"description": "List all recordset executions.",
				"operationId": "ListExecutions",
				"parameters": [
					{
						"description": "The requested page of records. Default is 1.",
						"format": "int32",
						"in": "query",
						"name": "pagination.page",
						"required": false,
						"type": "integer"
					},
					{
						"description": "The number of records to return per page. Maximum is 500. Default is 100.",
						"format": "int32",
						"in": "query",
						"name": "pagination.per_page",
						"required": false,
						"type": "integer"
					},
					{
						"description": "OrderBy is a comma seperated value to define sorting.",
						"in": "query",
						"name": "order_by",
						"required": false,
						"type": "string"
					},
					{
						"description": "Filter is a string containing logic that can specify a restricted set of Executions to be returned.",
						"in": "query",
						"name": "filter",
						"required": false,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Recordset_Creation.ListExecutionsResponse"
						}
					},
					"400": {
						"description": "Returned when the request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"404": {
						"description": "Returned when a resource is not found.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "List Executions.",
				"tags": [
					"Recordset Creation"
				]
			}
		},
		"/api/v2/recordset-creation/executions/{execution_id}": {
			"get": {
				"description": "Get the details of a specific recordset execution.",
				"operationId": "GetExecution",
				"parameters": [
					{
						"description": "The ID of the execution to get.",
						"in": "path",
						"name": "execution_id",
						"required": true,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Recordset_Creation.GetExecutionResponse"
						}
					},
					"400": {
						"description": "Returned when the request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"404": {
						"description": "Returned when the recordset execution could not be found.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Get a Recordset Execution.",
				"tags": [
					"Recordset Creation"
				]
			}
		},
		"/api/v2/recordset-creation/executions/{execution_id}/cancel": {
			"post": {
				"description": "Cancels a specific recordset execution.",
				"operationId": "CancelExecution",
				"parameters": [
					{
						"description": "The ID of the execution to cancel.",
						"in": "path",
						"name": "execution_id",
						"required": true,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Recordset_Creation.CancelExecutionResponse"
						}
					},
					"400": {
						"description": "Returned when the request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"404": {
						"description": "Returned when the Execution could not be found.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Cancel an Execution",
				"tags": [
					"Recordset Creation"
				]
			}
		},
		"/api/v2/recordsets/{cloud_vault_id}": {
			"get": {
				"description": "List available recordsets with any metadata",
				"operationId": "listRecordsets",
				"parameters": [
					{
						"description": "The globally unique identifier for the Cloud Vault where the recordset to delete is.",
						"in": "path",
						"name": "cloud_vault_id",
						"required": true,
						"type": "string"
					},
					{
						"description": "The requested page of records. Default is 1.",
						"format": "int32",
						"in": "query",
						"name": "pagination.page",
						"required": false,
						"type": "integer"
					},
					{
						"description": "The number of records to return per page. Maximum is 500. Default is 100.",
						"format": "int32",
						"in": "query",
						"name": "pagination.per_page",
						"required": false,
						"type": "integer"
					},
					{
						"in": "query",
						"name": "order_by",
						"required": false,
						"type": "string"
					},
					{
						"description": "Filter is a string containing logic that can specify a restricted set of\nRecordsets to be returned. e.g. `name co 'Test' or name co 'Acme'`. These are\nthe supported fields for filtering:\n  id\n  name\n  record_count\n  total_size\n  columns_headers\n  folder_path\n  is_publishable\n  origin_task_id\n  origin_task_type\n  origin_task_properties\n  created_date_time (in RFC3339 format)\n  updated_date_time (in RFC3339 format)",
						"in": "query",
						"name": "filter",
						"required": false,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Recordsets.ListResponse"
						}
					},
					"400": {
						"description": "Returned when the request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"404": {
						"description": "Returned when the Cloud Vault could not be found.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "List recordsets",
				"tags": [
					"Recordsets"
				]
			}
		},
		"/api/v2/recordsets/{cloud_vault_id}/{recordset_id}": {
			"delete": {
				"description": "Delete the specified recordset",
				"operationId": "deleteRecordset",
				"parameters": [
					{
						"description": "The globally unique identifier for the Cloud Vault where the Recordset to delete is.",
						"in": "path",
						"name": "cloud_vault_id",
						"required": true,
						"type": "string"
					},
					{
						"description": "The ID of the recordset to be deleted.",
						"in": "path",
						"name": "recordset_id",
						"required": true,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Recordsets.DeleteResponse"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Delete recordset",
				"tags": [
					"Recordsets"
				]
			},
			"get": {
				"description": "Gets information about a recordset along with any metadata",
				"operationId": "getRecordset",
				"parameters": [
					{
						"description": "The globally unique identifier for the Cloud Vault where the recordset to get is.",
						"in": "path",
						"name": "cloud_vault_id",
						"required": true,
						"type": "string"
					},
					{
						"description": "The ID of the recordset to get.",
						"in": "path",
						"name": "recordset_id",
						"required": true,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Recordsets.GetResponse"
						}
					},
					"400": {
						"description": "Returned when the request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"404": {
						"description": "Returned when the recordset could not be found.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Get information about a specific recordset",
				"tags": [
					"Recordsets"
				]
			},
			"patch": {
				"description": "Renames a recordset on a specific Cloud Vault.",
				"operationId": "renameRecordset",
				"parameters": [
					{
						"description": "The globally unique identifier for the Cloud Vault where the recordset to rename is.",
						"in": "path",
						"name": "cloud_vault_id",
						"required": true,
						"type": "string"
					},
					{
						"description": "The ID of the recordset to be renamed.",
						"in": "path",
						"name": "recordset_id",
						"required": true,
						"type": "string"
					},
					{
						"in": "body",
						"name": "body",
						"required": true,
						"schema": {
							"$ref": "#/definitions/Recordsets.RenameBody"
						}
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Recordsets.RenameResponse"
						}
					},
					"400": {
						"description": "Returned when the request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"404": {
						"description": "Returned when the Cloud Vault could not be found.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Renames a recordset.",
				"tags": [
					"Recordsets"
				]
			}
		},
		"/api/v2/recordsets/{cloud_vault_id}/{recordset_id}/columns": {
			"get": {
				"description": "List available recordset columns",
				"operationId": "listRecordsetColumns",
				"parameters": [
					{
						"description": "The globally unique identifier for the Cloud Vault where the recordset to get is.",
						"in": "path",
						"name": "cloud_vault_id",
						"required": true,
						"type": "string"
					},
					{
						"description": "The globally unique identifier for the Recordset where the recordset columns will be listed.",
						"in": "path",
						"name": "recordset_id",
						"required": true,
						"type": "string"
					},
					{
						"description": "The requested page of records. Default is 1.",
						"format": "int32",
						"in": "query",
						"name": "pagination.page",
						"required": false,
						"type": "integer"
					},
					{
						"description": "The number of records to return per page. Maximum is 500. Default is 100.",
						"format": "int32",
						"in": "query",
						"name": "pagination.per_page",
						"required": false,
						"type": "integer"
					},
					{
						"description": "OrderBy is a comma separated value to define sorting.\ne.g 'name DESC'.\nThe values are separated by space, '{column} {ASC/DESC}'.\nThese are the values that are sortable:\n  name\n  statistics.value_count\n  statistics.cell_count",
						"in": "query",
						"name": "order_by",
						"required": false,
						"type": "string"
					},
					{
						"description": "Filter is a string containing logic that can specify a restricted set of\nRecordsets to be returned. e.g. `name co 'Test' or name co 'Acme'`. These are\nthe supported fields for filtering:\n  name\n  value_type\n  statistics.value_count\n  statistics.cell_count\n  pii",
						"in": "query",
						"name": "filter",
						"required": false,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Recordsets.ListColumnsResponse"
						}
					},
					"400": {
						"description": "Returned when the request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"404": {
						"description": "Returned when the Recordset could not be found.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "List recordset columns",
				"tags": [
					"Recordsets"
				]
			}
		},
		"/api/v2/reports/insight": {
			"get": {
				"description": "List insight reports.",
				"operationId": "List",
				"parameters": [
					{
						"description": "The requested page of records. Default is 1.",
						"format": "int32",
						"in": "query",
						"name": "pagination.page",
						"required": false,
						"type": "integer"
					},
					{
						"description": "The number of records to return per page. Maximum is 500. Default is 100.",
						"format": "int32",
						"in": "query",
						"name": "pagination.per_page",
						"required": false,
						"type": "integer"
					},
					{
						"description": "The ordering for returned insight reports.",
						"in": "query",
						"name": "order_by",
						"required": false,
						"type": "string"
					},
					{
						"description": "Filter is a string containing logic that can specify a restricted set of\nreports to be returned. e.g. `name co 'Test' or name co 'Acme'`\n\nA string containing logic that can specify a restricted set of insight reports to be returned. e.g. `name eq 'Test' or name co 'Acme'`",
						"in": "query",
						"name": "filter",
						"required": false,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Reports.ListResponse"
						}
					},
					"400": {
						"description": "Returned when the List request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "List insight reports.",
				"tags": [
					"Reports"
				]
			},
			"post": {
				"description": "Create a new insight report.",
				"operationId": "Create",
				"parameters": [
					{
						"description": "CreateRequest is the Create rpc input.",
						"in": "body",
						"name": "body",
						"required": true,
						"schema": {
							"$ref": "#/definitions/Reports.CreateRequest"
						}
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Reports.CreateResponse"
						}
					},
					"400": {
						"description": "Returned when the Create request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Create a new insight report.",
				"tags": [
					"Reports"
				]
			}
		},
		"/api/v2/reports/insight/{report_id}": {
			"delete": {
				"description": "Delete an insight report.",
				"operationId": "Delete",
				"parameters": [
					{
						"description": "The uniquely identifying ID of an insight report.",
						"in": "path",
						"name": "report_id",
						"required": true,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Reports.DeleteResponse"
						}
					},
					"400": {
						"description": "Returned when the Delete request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Delete an insight report.",
				"tags": [
					"Reports"
				]
			}
		},
		"/api/v2/reports/insight/{report_id}/definition": {
			"get": {
				"description": "Get details of an insight report.",
				"operationId": "GetDefinition",
				"parameters": [
					{
						"description": "ReportID uniquely specifies an insight report.",
						"in": "path",
						"name": "report_id",
						"required": true,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Reports.GetDefinitionResponse"
						}
					},
					"400": {
						"description": "Returned when the GetDefinition request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"404": {
						"description": "Returned when the report ID isn't found.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Get details of an insight report.",
				"tags": [
					"Reports"
				]
			}
		},
		"/api/v2/reports/insight/{report_id}/results/cross": {
			"get": {
				"description": "Get a cross category result for a completed report.",
				"operationId": "GetCrossCategoryResult",
				"parameters": [
					{
						"description": "Report ID uniquely specifies an insight report.",
						"in": "path",
						"name": "report_id",
						"required": true,
						"type": "string"
					},
					{
						"description": "The name of the first category to get the cross category result for.",
						"in": "query",
						"name": "category_1",
						"required": false,
						"type": "string"
					},
					{
						"description": "The name of the second category to get the cross category result for.",
						"in": "query",
						"name": "category_2",
						"required": false,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Reports.GetCrossCategoryResultResponse"
						}
					},
					"400": {
						"description": "Returned when the GetCrossCategoryResultRequest request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"404": {
						"description": "Returned when the report ID isn't found.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Get a cross category result for a completed report.",
				"tags": [
					"Reports"
				]
			}
		},
		"/api/v2/reports/insight/{report_id}/results/singles": {
			"get": {
				"description": "List the single category results of a completed insight report.",
				"operationId": "ListSinglesResults",
				"parameters": [
					{
						"description": "Report ID uniquely specifies an insight report.",
						"in": "path",
						"name": "report_id",
						"required": true,
						"type": "string"
					},
					{
						"description": "The requested page of records. Default is 1.",
						"format": "int32",
						"in": "query",
						"name": "pagination.page",
						"required": false,
						"type": "integer"
					},
					{
						"description": "The number of records to return per page. Maximum is 500. Default is 100.",
						"format": "int32",
						"in": "query",
						"name": "pagination.per_page",
						"required": false,
						"type": "integer"
					},
					{
						"description": "The ordering for returned insight reports.",
						"in": "query",
						"name": "order_by",
						"required": false,
						"type": "string"
					},
					{
						"description": "Filter is a string containing logic that can specify a restricted set of\nreports to be returned. e.g. `category_name eq 'Category1' or category_name co 'string'`\n\nA string containing logic that can specify a restricted set of insight report results to be returned. e.g. `category_name eq 'Category1' or category_name co 'string'`",
						"in": "query",
						"name": "filter",
						"required": false,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Reports.ListSinglesResultsResponse"
						}
					},
					"400": {
						"description": "Returned when the ListResults request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"404": {
						"description": "Returned when the report ID isn't found.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "List the single category results of a completed insight report.",
				"tags": [
					"Reports"
				]
			}
		},
		"/api/v2/reports/insight/{report_id}/status": {
			"get": {
				"description": "Get the status of an insight report.",
				"operationId": "GetStatus",
				"parameters": [
					{
						"description": "ReportID uniquely specifies an insight report.",
						"in": "path",
						"name": "report_id",
						"required": true,
						"type": "string"
					}
				],
				"responses": {
					"200": {
						"description": "A successful response.",
						"schema": {
							"$ref": "#/definitions/Reports.GetStatusResponse"
						}
					},
					"400": {
						"description": "Returned when the GetStatus request was not valid.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"401": {
						"description": "Returned when the user could not be authorized.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"403": {
						"description": "Returned when the user does not have the required permission.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"404": {
						"description": "Returned when the report ID isn't found.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"500": {
						"description": "Internal Server Error",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					},
					"default": {
						"description": "An unexpected error response.",
						"schema": {
							"$ref": "#/definitions/Error"
						}
					}
				},
				"summary": "Get the status of an insight report.",
				"tags": [
					"Reports"
				]
			}
		}
	},
	"produces": [
		"application/json"
	],
	"schemes": [
		"https"
	],
	"security": [
		{
			"API Keys": []
		}
	],
	"securityDefinitions": {
		"API Keys": {
			"description": "Your API key.",
			"in": "header",
			"name": "Authorization",
			"type": "apiKey"
		}
	},
	"swagger": "2.0",
	"tags": [
		{
			"description": "Service for mapping users to their display name and companies.",
			"name": "Accounts"
		},
		{
			"description": "Service for estimating intersections between datasets to establish if they are connected by common keys.",
			"name": "Connections"
		},
		{
			"description": "Service for executing queries against datasets in the InfoSum platform.",
			"externalDocs": {
				"description": "InfoSum Support Portal Article",
				"url": "https://support.infosum.com/hc/en-us/articles/360018948258-Queries-overview"
			},
			"name": "Queries"
		},
		{
			"description": "Service for generating and managing data insight reports.",
			"name": "Reports"
		},
		{
			"description": "Service for managing configurations for scheduling and automating actions in the InfoSum platform.",
			"name": "Automation Configs"
		},
		{
			"description": "Service for fetching previous automation runs and triggering a manual run of an automation configuration.",
			"name": "Automation Execution"
		},
		{
			"description": "Service for managing datasets in the InfoSum platform.",
			"name": "Datasets"
		},
		{
			"description": "Service for inspecting the key and category statistics of published datasets.",
			"name": "Dataset Stats"
		},
		{
			"description": "Service for establishing the provenance of published datasets.",
			"name": "Dataset Lineage"
		},
		{
			"description": "Service for managing re-usable destination configurations for exporting data from the InfoSum platform.",
			"externalDocs": {
				"description": "InfoSum Support Portal Article",
				"url": "https://support.infosum.com/hc/en-us/articles/9775893457297-Destination-management"
			},
			"name": "Destinations"
		},
		{
			"description": "Service for triggering the export of an activation query to a pre-configured destination.",
			"externalDocs": {
				"description": "InfoSum Support Portal Article",
				"url": "https://support.infosum.com/hc/en-us/articles/12128356485778-Activation-integrations-overview"
			},
			"name": "Exports"
		},
		{
			"description": "Service for managing Cloud Vault data staging areas within the InfoSum platform.",
			"externalDocs": {
				"description": "InfoSum Support Portal Article",
				"url": "https://support.infosum.com/hc/en-us/articles/9867422712977-Cloud-Vault"
			},
			"name": "Cloud Vaults"
		},
		{
			"description": "Service for managing files within a Cloud Vault.",
			"name": "Files"
		},
		{
			"description": "Service for managing import connector configurations to connect to a remote data source.",
			"externalDocs": {
				"description": "InfoSum Support Portal Article",
				"url": "https://support.infosum.com/hc/en-us/articles/17034029721618-Importing-into-your-Cloud-Vault-via-the-Import-Flow"
			},
			"name": "Import Connectors"
		},
		{
			"description": "Service for managing importers, which combine an import connector configuration with file patterns to allow for easy re-importing of data.",
			"externalDocs": {
				"description": "InfoSum Support Portal Article",
				"url": "https://support.infosum.com/hc/en-us/articles/16335527583506-Create-a-Recordset"
			},
			"name": "Importers"
		},
		{
			"description": "Service presenting the global schema keys and categories that columns can be mapped to during normalization.",
			"externalDocs": {
				"description": "InfoSum Support Portal Article",
				"url": "https://support.infosum.com/hc/en-us/articles/360018963897-Global-Schema"
			},
			"name": "Global Schema"
		},
		{
			"description": "Service for managing configurations for normalizing data.",
			"externalDocs": {
				"description": "InfoSum Support Portal Article",
				"url": "https://support.infosum.com/hc/en-us/articles/16863062437266-Sigma-Normalisation"
			},
			"name": "Normalization Config"
		},
		{
			"description": "Service for normalizing data using a normalization configuration ready for publishing to a dataset.",
			"externalDocs": {
				"description": "InfoSum Support Portal Article",
				"url": "https://support.infosum.com/hc/en-us/articles/16863062437266-Sigma-Normalisation"
			},
			"name": "Normalizations"
		},
		{
			"description": "Service for managing configurations to prepare a normalised recordset for publishing.",
			"externalDocs": {
				"description": "InfoSum Support Portal Article",
				"url": "https://support.infosum.com/hc/en-us/articles/16910773273106-Preparing-publishing-data-to-a-Bunker"
			},
			"name": "Prepare Configs"
		},
		{
			"description": "Service for preparing data using configurations, and publishing the prepared data to a dataset.",
			"externalDocs": {
				"description": "InfoSum Support Portal Article",
				"url": "https://support.infosum.com/hc/en-us/articles/16910773273106-Preparing-publishing-data-to-a-Bunker"
			},
			"name": "Publishing"
		},
		{
			"description": "Service for managing recordsets created as a result of normalisation or a recordset task executed using imported files.",
			"externalDocs": {
				"description": "InfoSum Support Portal Article",
				"url": "https://support.infosum.com/hc/en-us/articles/16335527583506-Create-a-Recordset"
			},
			"name": "Recordsets"
		},
		{
			"description": "Service for managing configurations for creating recordsets from imported files.",
			"externalDocs": {
				"description": "InfoSum Support Portal Article",
				"url": "https://support.infosum.com/hc/en-us/articles/16335527583506-Create-a-Recordset"
			},
			"name": "Recordset Configs"
		},
		{
			"description": "Service for creating recordsets using a stored configuration from imported files.",
			"externalDocs": {
				"description": "InfoSum Support Portal Article",
				"url": "https://support.infosum.com/hc/en-us/articles/16335527583506-Create-a-Recordset"
			},
			"name": "Recordset Creation"
		}
	],
	"x-tagGroups": [
		{
			"name": "Accounts",
			"tags": [
				"Accounts"
			]
		},
		{
			"name": "Analysis",
			"tags": [
				"Connections",
				"Queries",
				"Reports"
			]
		},
		{
			"name": "Automations",
			"tags": [
				"Automation Configs",
				"Automation Execution"
			]
		},
		{
			"name": "Datasets",
			"tags": [
				"Datasets",
				"Dataset Stats",
				"Dataset Lineage"
			]
		},
		{
			"name": "Export",
			"tags": [
				"Destination Instances",
				"Destination Shares",
				"Activation Destinations",
				"Activation Pushes"
			]
		},
		{
			"name": "File Management",
			"tags": [
				"Cloud Vaults",
				"Files"
			]
		},
		{
			"name": "Import",
			"tags": [
				"Import Connectors",
				"Importers",
				"Import Executions"
			]
		},
		{
			"name": "Normalization",
			"tags": [
				"Global Schema",
				"Normalization Config",
				"Normalizations"
			]
		},
		{
			"name": "Publishing",
			"tags": [
				"Prepare Configs",
				"Publishing"
			]
		},
		{
			"name": "Recordsets",
			"tags": [
				"Recordsets",
				"Recordset Configs",
				"Recordset Creation"
			]
		}
	]
}